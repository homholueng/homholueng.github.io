<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>live in passion</title>
  <icon>https://www.gravatar.com/avatar/c240f1720ed8361caf329d7e173987fe</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://homholueng.github.io/"/>
  <updated>2019-11-27T02:45:39.980Z</updated>
  <id>https://homholueng.github.io/</id>
  
  <author>
    <name>Homho Lueng</name>
    <email>your email</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python asyncio High-level APIs</title>
    <link href="https://homholueng.github.io/2019/11/25/python-asyncio/"/>
    <id>https://homholueng.github.io/2019/11/25/python-asyncio/</id>
    <published>2019-11-25T15:24:50.000Z</published>
    <updated>2019-11-27T02:45:39.980Z</updated>
    
    <content type="html"><![CDATA[<p>asyncio 是 Python 官方提供的用于编写并发程序的库，特别是在 Python 3.6 之后，官方通过添加 <code>async/await</code> 关键字来支持了原生的协程，这使得我们不需要再使用传统的生成器来编写协程，而在 Python 3.7 之后，官方对 <a href="https://docs.python.org/3.7/library/asyncio.html" target="_blank" rel="noopener">asyncio</a> 库进行了调整，提供了更为抽象的高层接口，使得这个库的易用程度大大提高，通过这些上层接口，我们能够：</p><ul><li>并发的执行 Python 协程，病能够很好的对其进行管理</li><li>进行网络 IO 和进程间通信</li><li>控制子进程</li><li>通过队列来执行分布式任务</li><li>同步并发代码</li></ul><h2 id="Croutines-and-Tasks"><a href="#Croutines-and-Tasks" class="headerlink" title="Croutines and Tasks"></a>Croutines and Tasks</h2><p>在 Python 3.6 之后，用 <code>async/await</code> 修饰的函数我们称之为协程，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'world'</span>)</span><br></pre></td></tr></table></figure><p>上面的程序在打印了 hello 之后，会调用 <code>asyncio.sleep</code> 函数睡眠一秒，此时 main 会将执行权交出去，执行流程会回到当前运行循环中，让下一个准备好的协程执行。<strong>需要注意的是，一旦我们的程序决定使用协程来实现，我们就不应该在协程中调用会阻塞当前线程的函数，不然会阻塞整个运行循环，就失去了并发程序间互相协作的意义，这就是为什么我们在这里低啊用 <code>asyncio.sleep</code> 而不是 <code>time.sleep</code> 的原因，前者会将控制权交还给运行循环。</strong></p><h3 id="Run-a-coroutine"><a href="#Run-a-coroutine" class="headerlink" title="Run a coroutine"></a>Run a coroutine</h3><p>我们有三种方式来执行一个协程：</p><ol><li><code>asyncio.run()</code>，一般通过这个函数来运行最顶层的协程</li><li><code>await</code> 关键字，通过这个关键字我们能够在协程中调用其他的协程</li><li><code>asyncio.create_task()</code>，使用这个函数能够以 task 的形式执行多个协程，使用这个方式来执行协程的意义在于，我们能够获得一个 <code>Task</code> 对象，通过这个对象我们能够实现对协程的一些控制行为</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">say_after</span><span class="params">(delay, what)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    print(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>上述代码中的 main 协程也可以替换成下面这种实现方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task1 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">1</span>, <span class="string">'hello'</span>))</span><br><span class="line"></span><br><span class="line">    task2 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">2</span>, <span class="string">'world'</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait until both tasks are completed (should take</span></span><br><span class="line">    <span class="comment"># around 2 seconds.)</span></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><h3 id="Awaitables"><a href="#Awaitables" class="headerlink" title="Awaitables"></a>Awaitables</h3><p>如果一个对象能够对其使用 <code>await</code> 关键字，那么该对象就是一个 <code>awaitable</code> 的对象。在 asyncio 中，主要有下面三种 awaitable 对象：</p><ol><li>croutines：使用 <code>async def</code> 关键字定义的函数或是调用协程函数返回的对象</li><li>tasks：调用 <code>asyncio.create_task</code> 返回的 Task 对象，通常使用 Task 对象来同时调度多个协程</li><li>futures：这是一个底层实现中使用的对象，其表示一个异步操作最终会产生的结果；一般来说，使用高层 API 时我们都不会接触到这种对象</li></ol><h3 id="Running-Tasks-Concurrently"><a href="#Running-Tasks-Concurrently" class="headerlink" title="Running Tasks Concurrently"></a>Running Tasks Concurrently</h3><p>如果要同时执行多个协程，asyncio 提供了一个便捷函数 gather 供我们使用：<code>awaitable asyncio.gather(*aws, return_exceptions=False)</code>。其会按照 aws 中传入的协程的顺序来并发的执行他们，如果 aws 中传入的对象是 awaitable 的，那么 gather 就会将其作为一个 Task 对象进行调度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(name, number)</span>:</span></span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: Compute factorial(<span class="subst">&#123;i&#125;</span>)..."</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        f *= i</span><br><span class="line">    print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: factorial(<span class="subst">&#123;number&#125;</span>) = <span class="subst">&#123;f&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Schedule three calls *concurrently*:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        factorial(<span class="string">"A"</span>, <span class="number">2</span>),</span><br><span class="line">        factorial(<span class="string">"B"</span>, <span class="number">3</span>),</span><br><span class="line">        factorial(<span class="string">"C"</span>, <span class="number">4</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     Task A: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task A: factorial(2) = 2</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(3)...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(3)...</span></span><br><span class="line"><span class="comment">#     Task B: factorial(3) = 6</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(4)...</span></span><br><span class="line"><span class="comment">#     Task C: factorial(4) = 24</span></span><br></pre></td></tr></table></figure><p>如果 <code>return_exceptions</code> 参数为 <code>True</code>，则协程中抛出的异常会被当做结果返回，否则 gather 函数会抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">simport asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> Exception()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro_n</span><span class="params">(num)</span>:</span></span><br><span class="line">    print(<span class="string">'coro'</span>, num)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(num)</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(coro1(), coro_n(<span class="number">2</span>), coro_n(<span class="number">3</span>), return_exceptions=<span class="literal">True</span>)</span><br><span class="line">    print(results)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment"># coro 2</span></span><br><span class="line"><span class="comment"># coro 3</span></span><br><span class="line"><span class="comment"># [Exception(), 2, 3]</span></span><br></pre></td></tr></table></figure><p>如果 <code>return_exceptions</code> 为 <code>False</code>，则会抛出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ipython-input-3-cf6ac787bf10&gt; in main()</span><br><span class="line">     13 </span><br><span class="line">     14 async def main():</span><br><span class="line">---&gt; 15     results = await asyncio.gather(coro1(), coro_n(2), coro_n(3), return_exceptions=False)</span><br><span class="line">     16     print(results)</span><br><span class="line">     17 </span><br><span class="line"></span><br><span class="line">&lt;ipython-input-3-cf6ac787bf10&gt; in coro1()</span><br><span class="line">      3 </span><br><span class="line">      4 async def coro1():</span><br><span class="line">----&gt; 5     raise Exception()</span><br><span class="line">      6 </span><br><span class="line">      7</span><br></pre></td></tr></table></figure><h3 id="Shielding-From-Cancellation"><a href="#Shielding-From-Cancellation" class="headerlink" title="Shielding From Cancellation"></a>Shielding From Cancellation</h3><p>我们可以使用 <code>shield</code> 函数来防止一个协程被 <code>calcel()</code> 调用影响：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="keyword">await</span> shield(something())</span><br></pre></td></tr></table></figure><p>但是如果正在执行 <code>something</code> 的协程被取消了，虽然此时 <code>something</code> 本身没有被取消，但是这条 <code>await</code> 语句还是会抛出 <code>CancelledError</code>。</p><h3 id="Timeouts"><a href="#Timeouts" class="headerlink" title="Timeouts"></a>Timeouts</h3><p><code>asyncio.wait_for(aw, timeout, *)</code> 等待 <code>aw</code> 协程在超时时间内完成，否则抛出 <code>TimeoutError</code> 异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">eternity</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Sleep for one hour</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    print(<span class="string">'yay!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Wait for at most 1 second</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait_for(eternity(), timeout=<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.TimeoutError:</span><br><span class="line">        print(<span class="string">'timeout!'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h3 id="Waiting-Primitives"><a href="#Waiting-Primitives" class="headerlink" title="Waiting Primitives"></a>Waiting Primitives</h3><p><code>asyncio.wait(aws, *, timeout=None, return_when=ALL_COMPLETED)</code> 会执行 <code>aws</code> 并阻塞到 <code>return_when</code> 参数中指定的条件满足位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">done, pending = <span class="keyword">await</span> asyncio.wait(aws)</span><br></pre></td></tr></table></figure><p><code>return_when</code> 有以下选项：</p><ul><li><code>FIRST_COMPLETED</code>：函数将在任意一个 future 完成或被取消后返回。</li><li><code>FIRST_EXCEPTION</code>：函数将在任意一个 future 抛出异常后返回，如果没有任何异常抛出，其等同于 <code>ALL_COMPLETED</code>。</li><li><code>ALL_COMPLETED</code>：函数将在所有 future 完成或被取消后返回。</li></ul><h3 id="Scheduling-From-Other-Threads"><a href="#Scheduling-From-Other-Threads" class="headerlink" title="Scheduling From Other Threads"></a>Scheduling From Other Threads</h3><p><code>asyncio.run_coroutine_threadsafe(coro, loop)</code> 能够让我们在另一个线程中执行协程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a coroutine</span></span><br><span class="line">coro = asyncio.sleep(<span class="number">1</span>, result=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Submit the coroutine to a given loop</span></span><br><span class="line">future = asyncio.run_coroutine_threadsafe(coro, loop)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for the result with an optional timeout argument</span></span><br><span class="line"><span class="keyword">assert</span> future.result(timeout) == <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="Introspection"><a href="#Introspection" class="headerlink" title="Introspection"></a>Introspection</h3><ul><li><code>asyncio.current_task(loop=None)</code>：返回当前正在执行的 Task 实例，如果当前没有任务在执行则返回 <code>None</code></li><li><code>asyncio.all_tasks(loop=None)</code>：返回 loop 中尚未执行完成的 Task 集合</li></ul><p>如果 <code>loop</code> 参数为 <code>None</code>，函数内部会使用 <code>get_running_loop()</code> 来获取当前运行循环。</p><h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p>Streams 提供了高层可用 <code>async/await</code> 关键字操作网络连接的借口，下面是用 Streams 编写的 TCP 回显客户端和 TCP 回显服务器</p><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">tcp_echo_client</span><span class="params">(message)</span>:</span></span><br><span class="line">    reader, writer = <span class="keyword">await</span> asyncio.open_connection(</span><br><span class="line">        <span class="string">'127.0.0.1'</span>, <span class="number">8888</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f'Send: <span class="subst">&#123;message!r&#125;</span>'</span>)</span><br><span class="line">    writer.write(message.encode())</span><br><span class="line"></span><br><span class="line">    data = <span class="keyword">await</span> reader.read(<span class="number">100</span>)</span><br><span class="line">    print(<span class="string">f'Received: <span class="subst">&#123;data.decode()!r&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Close the connection'</span>)</span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line">asyncio.run(tcp_echo_client(<span class="string">'Hello World!'</span>))</span><br></pre></td></tr></table></figure><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle_echo</span><span class="params">(reader, writer)</span>:</span></span><br><span class="line">    data = <span class="keyword">await</span> reader.read(<span class="number">100</span>)</span><br><span class="line">    message = data.decode()</span><br><span class="line">    addr = writer.get_extra_info(<span class="string">'peername'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"Received <span class="subst">&#123;message!r&#125;</span> from <span class="subst">&#123;addr!r&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"Send: <span class="subst">&#123;message!r&#125;</span>"</span>)</span><br><span class="line">    writer.write(data)</span><br><span class="line">    <span class="keyword">await</span> writer.drain()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Close the connection"</span>)</span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    server = <span class="keyword">await</span> asyncio.start_server(</span><br><span class="line">        handle_echo, <span class="string">'127.0.0.1'</span>, <span class="number">8888</span>)</span><br><span class="line"></span><br><span class="line">    addr = server.sockets[<span class="number">0</span>].getsockname()</span><br><span class="line">    print(<span class="string">f'Serving on <span class="subst">&#123;addr&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> server:</span><br><span class="line">        <span class="keyword">await</span> server.serve_forever()</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h2 id="Synchronization-Primitives"><a href="#Synchronization-Primitives" class="headerlink" title="Synchronization Primitives"></a>Synchronization Primitives</h2><p>虽然并发程序设计很大程度上涉及了代码之间协作的模式，但是总有一些情况下我们还是要对代码的执行进行同步，因为运行循环的行为不是我们能够控制的，这就需要借助各种同步原语提供的能力了。</p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>互斥锁，使用方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">lock_competitor</span><span class="params">(n, lock)</span>:</span></span><br><span class="line">    print(<span class="string">f"competitor<span class="subst">&#123;n&#125;</span> try to get lock"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> lock:</span><br><span class="line">        print(<span class="string">f"competitor<span class="subst">&#123;n&#125;</span> get the lock"</span>)</span><br><span class="line">        print(<span class="string">f"competitor sleep for <span class="subst">&#123;n&#125;</span> seconds..."</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(n)</span><br><span class="line">        print(<span class="string">f"competitor<span class="subst">&#123;n&#125;</span> wake up!"</span>)</span><br><span class="line">        print(<span class="string">f"competitor<span class="subst">&#123;n&#125;</span> give up the lock"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    lock = asyncio.Lock()</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*[lock_competitor(n, lock) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>)])</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>当然，也可以采用传统的模式来获取互斥锁，但还是推荐使用 <code>async with</code> 关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock = asyncio.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ... later</span></span><br><span class="line"><span class="keyword">await</span> lock.acquire()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># access shared state</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    lock.release()</span><br></pre></td></tr></table></figure><p>注意，互斥锁是公平的，这意味这先尝试获取锁的协程会在锁可用后先得到锁。</p><h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><p>事件能够用于通知多个 asyncio 任务某件事情已经发生了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">waiter</span><span class="params">(event)</span>:</span></span><br><span class="line">    print(<span class="string">'waiting for it ...'</span>)</span><br><span class="line">    <span class="keyword">await</span> event.wait()</span><br><span class="line">    print(<span class="string">'... got it!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Create an Event object.</span></span><br><span class="line">    event = asyncio.Event()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Spawn a Task to wait until 'event' is set.</span></span><br><span class="line">    waiter_task = asyncio.create_task(waiter(event))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Sleep for 1 second and set the event.</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    event.set()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait until the waiter task is finished.</span></span><br><span class="line">    <span class="keyword">await</span> waiter_task</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>Condition 可以用于让多个任务等待某些事件的发生，一旦事件发生后这些任务会尝试去互斥的访问某些共享的资源。Condition 就像是 Lock 和 Event 的结合。但是，多个 Condition 对象能够绑定同一个锁，这就能够让对不同事件感兴趣却需要访问同一个共享资源的任务间进行同步操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cond = asyncio.Condition()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ... later</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> cond:</span><br><span class="line">    <span class="keyword">await</span> cond.wait()</span><br></pre></td></tr></table></figure><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>即传统的信号量，当内置的计数器等于 0 时，则当前执行的任务会让出调度权：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sem = asyncio.Semaphore(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ... later</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> sem:</span><br><span class="line">    <span class="comment"># work with shared resource</span></span><br></pre></td></tr></table></figure><h3 id="BoundedSemaphore"><a href="#BoundedSemaphore" class="headerlink" title="BoundedSemaphore"></a>BoundedSemaphore</h3><p>特殊版本的 Semaphore，若调用 <code>release()</code> 后其内置计数器的值大于初始值，则会抛出 <code>ValueError</code>。</p><h2 id="Subprocesses"><a href="#Subprocesses" class="headerlink" title="Subprocesses"></a>Subprocesses</h2><p>asyncio 还提供了 API 来让我们创建和管理子进程，下面是一个使用子进程来执行命令的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(cmd)</span>:</span></span><br><span class="line">    proc = <span class="keyword">await</span> asyncio.create_subprocess_shell(</span><br><span class="line">        cmd,</span><br><span class="line">        stdout=asyncio.subprocess.PIPE,</span><br><span class="line">        stderr=asyncio.subprocess.PIPE)</span><br><span class="line"></span><br><span class="line">    stdout, stderr = <span class="keyword">await</span> proc.communicate()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f'[<span class="subst">&#123;cmd!r&#125;</span> exited with <span class="subst">&#123;proc.returncode&#125;</span>]'</span>)</span><br><span class="line">    <span class="keyword">if</span> stdout:</span><br><span class="line">        print(<span class="string">f'[stdout]\n<span class="subst">&#123;stdout.decode()&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">if</span> stderr:</span><br><span class="line">        print(<span class="string">f'[stderr]\n<span class="subst">&#123;stderr.decode()&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(run(<span class="string">'ls /zzz'</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;asyncio 是 Python 官方提供的用于编写并发程序的库，特别是在 Python 3.6 之后，官方通过添加 &lt;code&gt;async/await&lt;/code&gt; 关键字来支持了原生的协程，这使得我们不需要再使用传统的生成器来编写协程，而在 Python 3.7 之后，
      
    
    </summary>
    
      <category term="Fluent Python" scheme="https://homholueng.github.io/categories/Fluent-Python/"/>
    
    
      <category term="Python" scheme="https://homholueng.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 21 - 类元编程</title>
    <link href="https://homholueng.github.io/2019/11/03/fluent-python-meta-class/"/>
    <id>https://homholueng.github.io/2019/11/03/fluent-python-meta-class/</id>
    <published>2019-11-03T12:38:12.000Z</published>
    <updated>2019-11-03T12:56:40.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="21-1-类工厂函数"><a href="#21-1-类工厂函数" class="headerlink" title="21.1 类工厂函数"></a>21.1 类工厂函数</h2><p>其实我们经常使用的 <code>collections.namedtuple</code> 就是一个类工厂函数，我们把类名和几个属性名传给这个函数，它就会创建一个 tuple 的子类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_factory</span><span class="params">(cls_name, field_names)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        field_names = field_names.replace(<span class="string">','</span>, <span class="string">' '</span>).split()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    field_names = tuple(field_names)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        attrs = dict(zip(self.__slots__, args))</span><br><span class="line">        attrs.update(kwargs)</span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs.items():</span><br><span class="line">            setattr(self, name, value)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.__slots__:</span><br><span class="line">            <span class="keyword">yield</span> getattr(self, name)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        values =  <span class="string">', '</span>.join(<span class="string">'&#123;&#125;=&#123;!r&#125;'</span>.format(*i) <span class="keyword">for</span> i <span class="keyword">in</span> zip(self.__slots__, self))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;&#125;)'</span>.format(self.__class__.__Name__, values)</span><br><span class="line"></span><br><span class="line">    cls_attrs = dict(</span><br><span class="line">        __slots__=field_names,</span><br><span class="line">        __init__=__init__,</span><br><span class="line">        __iter__=__iter__,</span><br><span class="line">        __repr__=__repr__</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> type(cls_name, (object,), cls_attrs)</span><br></pre></td></tr></table></figure><p>通常，我们把 type 视作函数，因为我们像函数那样使用它，例如，调用 <code>type(my_object)</code> 获取对象所属的类——作用与 <code>my_object.__class__</code> 相同。然而，<code>type</code> 是一个类。当成类使用时，传入三个参数可以新建一个类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass = type(<span class="string">'MyClass'</span>, (MySuperClass, MyMixin), &#123;<span class="string">'x'</span>: <span class="number">42</span> <span class="string">'x2'</span>: <span class="keyword">lambda</span> self : self.x * <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure><p><code>type</code> 的三个参数分别是 <code>name</code>、<code>bases</code> 和 <code>dict</code>。最后一个参数是一个映射，指定新类的属性名和值。上述代码的作用与下述代码相同:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(MySUperClass, MyMixin)</span>:</span></span><br><span class="line">    x = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x * <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="21-2-定制描述符的类装饰器"><a href="#21-2-定制描述符的类装饰器" class="headerlink" title="21.2 定制描述符的类装饰器"></a>21.2 定制描述符的类装饰器</h2><p>类装饰器与函数装饰器非常类似，是参数为类对象的函数，返回原来的类或修改后的类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">entity</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, attr <span class="keyword">in</span> cls.__dict__.items():</span><br><span class="line">        <span class="keyword">if</span> isintance(attr, Validated):</span><br><span class="line">            type_name = type(attr).__name__</span><br><span class="line">            attr.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cls</span><br></pre></td></tr></table></figure><p>类装饰器有个重大缺点: 只对直接依附的类有效。这意味着，被装饰的类的子类可能继承也可能不继承装饰器所做的改动，具体情况视改动的方式而定。</p><h2 id="21-3-导入时和运行时比较"><a href="#21-3-导入时和运行时比较" class="headerlink" title="21.3 导入时和运行时比较"></a>21.3 导入时和运行时比较</h2><p>导入模块时，解释器会执行顶层的 def 语句，可是这么做有什么作用呢?解释器会编译函数的定义体(首次导入模块时)，把函数对象绑定到对应的全局名称上，但是显然解释器不会执行函数的定义体。</p><p>对类来说，情况就不同了:在导入时，解释器会执行每个类的定义体，甚至会执行嵌套类的定义体。执行类定义体的结果是，定义了类的属性和方法，并构建了类对象。</p><h2 id="21-4-元类基础知识"><a href="#21-4-元类基础知识" class="headerlink" title="21.4 元类基础知识"></a>21.4 元类基础知识</h2><p>元类是制造类的工厂，不过不是函数，而是类。</p><p>根据 Python 的对象模型，类是对象，因此类肯定是另外某个类的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="string">'spam'</span>.__class__                  </span><br><span class="line">Out[<span class="number">1</span>]: str</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: str.__class__                  </span><br><span class="line">Out[<span class="number">2</span>]: type</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: str.__class__                 </span><br><span class="line">Out[<span class="number">3</span>]: type</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: type.__class__</span><br><span class="line">Out[<span class="number">4</span>]: type</span><br></pre></td></tr></table></figure><p>为了避免无限回溯，<code>type</code> 是其自身的实例，如最后一行所示。</p><p>除了 <code>type</code>，标准库中还有一些别的元类，例如 <code>ABCMeta</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: collections.Iterable.__class__</span><br><span class="line">Out[<span class="number">2</span>]: abc.ABCMeta</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: abc.ABCMeta.__class__  </span><br><span class="line">Out[<span class="number">4</span>]: type</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: abc.ABCMeta.__mro__</span><br><span class="line">Out[<span class="number">5</span>]: (abc.ABCMeta, type, object)</span><br></pre></td></tr></table></figure><p>向上追溯，<code>ABCMeta</code> 最终所属的类也是 <code>type</code>。所有类都直接或间接地是 <code>type</code> 的实例，不过只有元类同时也是 <code>type</code> 的子类。若想理解元类，一定要知道这种关系:元类(如 <code>ABCMeta</code>)从 <code>type</code> 类继承了构建类的能力。</p><img src="/2019/11/03/fluent-python-meta-class/meta.png"><p>我们要抓住的重点是，所有类都是 <code>type</code> 的实例，但是元类还是 <code>type</code> 的子类，因此可以作为制造类的工厂。具体来说，元类可以通过实现 <code>__init__</code> 方法定制实例。元类的 <code>__init__</code> 方法可以做到类装饰器能做的任何事情，但是作用更大。元类的 <code>__init__</code> 方法有四个参数：</p><ul><li><code>self</code>：要初始化的类对象（一般改名为 <code>cls</code>）</li><li><code>name</code>：类名</li><li><code>bases</code>：基类列表</li><li><code>dic</code>：类的属性名和值</li></ul><h2 id="21-5-定制描述符的元类"><a href="#21-5-定制描述符的元类" class="headerlink" title="21.5 定制描述符的元类"></a>21.5 定制描述符的元类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntityMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, attr_dict)</span>:</span></span><br><span class="line">        super().__init__(name, bases, attr_dict)</span><br><span class="line">        <span class="keyword">for</span> key, attr <span class="keyword">in</span> attr_dict.items():</span><br><span class="line">            <span class="keyword">if</span> isinstance(attr, Validated):</span><br><span class="line">                type_name = type(attr).__name__</span><br><span class="line">                attr.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">(metaclass=EntityMeta)</span>:</span></span><br><span class="line">    <span class="string">"""带有验证字段的业务实体"""</span></span><br></pre></td></tr></table></figure><p>因为元类会影响使用期作为元类的类及所有子类的初始化，所以我们可以在元类中定义一些行为，这样就能够作用在整个类继承链条的类上。</p><h2 id="21-6-元类的特殊方法-prepare"><a href="#21-6-元类的特殊方法-prepare" class="headerlink" title="21.6 元类的特殊方法 __prepare__"></a>21.6 元类的特殊方法 <code>__prepare__</code></h2><p>在某些应用中，可能需要知道类的属性定义的顺序。如前所述，<code>type</code> 构造方法及元类的 <code>__new__</code> 和 <code>__init__</code> 方法都会收到要计算的类的定义体，形式是名称到属性的映像。然而在默认情况下，那个映射是字典;也就是说，元类或类装饰器获得映射时，属性在类定义体中的顺序已经丢失了。</p><p>这个问题的解决办法是，使用 Python 3 引入的特殊方法 <code>__prepare__</code>。 这个特殊方法只在元类中有用，而且必须声明为类方法(即要使用 <code>@classmethod</code> 装饰器定义)。解释器调用元类的 <code>__new__</code> 方法之前会先调用 <code>__prepare__</code> 方法，使用类定义体中的属性创建映射。</p><p><code>__prepare__</code> 方法的第一个参数是元类，随后两个参数分别是要构建的<em>类的名称</em>和<em>基类组成的元组</em>，返回值必须是<strong>映射</strong>。元类构建新类时，<code>__prepare__</code> 方法返回的映射会传给 <code>__new__</code> 方法的最后一个参数，然后再传给 <code>__init__</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntityMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span><span class="params">(cls, name, bases)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> collections.OrderedDict()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, attr_dict)</span>:</span></span><br><span class="line">        super().__init__(name, bases, attr_dict)</span><br><span class="line">        cls._field_names = []</span><br><span class="line">        <span class="keyword">for</span> key, attr <span class="keyword">in</span> attr_dict.items():</span><br><span class="line">            <span class="keyword">if</span> isinstance(attr, Validated):</span><br><span class="line">                type_name = type(attr).__name__</span><br><span class="line">                attr.storage_name = <span class="string">'&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line">                cls._field_names.append(key)</span><br></pre></td></tr></table></figure><p>在上述例子中，由于 <code>__prepare__</code> 方法返回的是一个有序的字典，所以在 <code>__init__</code> 中的 for 循环里我们能够根据属性定义的顺序来进行遍历。</p><p>在现实世界中，框架和库会使用元类协助程序员执行很多任务，例如:</p><ul><li>验证属性 </li><li>一次把装饰器依附到多个方法上 </li><li>序列化对象或转换数据 </li><li>对象关系映射</li><li>基于对象的持久存储 </li><li>动态转换使用其他语言编写的类结构</li></ul><h2 id="21-7-类作为对象"><a href="#21-7-类作为对象" class="headerlink" title="21.7 类作为对象"></a>21.7 类作为对象</h2><p><code>cls.__bases__</code>：由类的基类组成的元组。<br><code>cls.__qualname__</code>：Python 3.3 新引入的属性，其值是类或函数的限定名称，即从模块的全局作用域到类的点分路径。<br><code>cls.__subclasses__()</code>：这个方法返回一个列表，包含类的直接子类。<br><code>cls.mro()</code>：构建类时，如果需要获取储存在类属性 <code>__mro__</code> 中的超类元组，解释器会调用这个方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;21-1-类工厂函数&quot;&gt;&lt;a href=&quot;#21-1-类工厂函数&quot; class=&quot;headerlink&quot; title=&quot;21.1 类工厂函数&quot;&gt;&lt;/a&gt;21.1 类工厂函数&lt;/h2&gt;&lt;p&gt;其实我们经常使用的 &lt;code&gt;collections.namedtuple
      
    
    </summary>
    
      <category term="Fluent Python" scheme="https://homholueng.github.io/categories/Fluent-Python/"/>
    
    
      <category term="Python" scheme="https://homholueng.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 20 - 属性描述符</title>
    <link href="https://homholueng.github.io/2019/11/03/fluent-python-attribute-descriptor/"/>
    <id>https://homholueng.github.io/2019/11/03/fluent-python-attribute-descriptor/</id>
    <published>2019-11-03T12:37:52.000Z</published>
    <updated>2019-11-03T12:56:40.386Z</updated>
    
    <content type="html"><![CDATA[<p><strong>描述符是对多个属性运用相同存取逻辑的一种方式，是实现了特定协议的类，这个协议包括 <code>__get__</code>、<code>__set__</code> 和 <code>__delete__</code> 方法。</strong></p><h2 id="20-1-描述符示例：验证属性"><a href="#20-1-描述符示例：验证属性" class="headerlink" title="20.1 描述符示例：验证属性"></a>20.1 描述符示例：验证属性</h2><h3 id="20-1-1-一个简单的描述符"><a href="#20-1-1-一个简单的描述符" class="headerlink" title="20.1.1　一个简单的描述符"></a>20.1.1　一个简单的描述符</h3><p>实现了 <code>__get__</code>、<code>__set__</code> 或 <code>__delete__</code> 方法的类是描述符。描述符的用法是，创建一个实例，作为另一个类的类属性。</p><p>在学习使用描述符前，需要先清除以下概念：</p><ul><li>描述符类：实现描述符协议的类</li><li>托管类：把描述符实例声明为类属性的类</li><li>描述符实例：描述符类的各个实例，声明为托管类的类属性</li><li>托管实例：托管类的实例</li><li>存储属性：托管实例中存储自身托管属性的属性</li><li>托管属性：托管类中由描述符实例处理的公开属性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, storage_name)</span>:</span></span><br><span class="line">        self.storage_name = storage_name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[self.storage_name] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    weight = Quantity(<span class="string">'weight'</span>)</span><br><span class="line">    price = Quantity(<span class="string">'price'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><blockquote><p>编写 <code>__set__</code> 方法时，要记住 <code>self</code> 和 <code>instance</code> 参数的意思：<code>self</code> 是描述符实例，<code>instance</code> 是托管实例。</p></blockquote><h3 id="20-1-3-一种新型描述符"><a href="#20-1-3-一种新型描述符" class="headerlink" title="20.1.3 一种新型描述符"></a>20.1.3 一种新型描述符</h3><p>我们可以将描述符定义中通用的部分提取出来，将一些可能有开发者自定义的部分放开让子类来实现，采用模板方法的设计模式来进行抽象和简化：</p><img src="/2019/11/03/fluent-python-attribute-descriptor/new_style_descriptor.png"><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoStorage</span>:</span></span><br><span class="line">    __counter = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        prefix = cls.__name__</span><br><span class="line">        index = cls.__counter__</span><br><span class="line">        self.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(prefix, index)</span><br><span class="line">        cls.__counter += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        setattr(instance, self.storage_name, value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validated</span><span class="params">(abc.ABC, AutoStorage)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = self.validate(instance, value)</span><br><span class="line">        super().__set__(instance, value)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="string">"""return validated value or raise ValueError"""</span></span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">(Validated)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BonBlank</span><span class="params">(Validated)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, isinstance, value)</span>:</span></span><br><span class="line">        value = value.strip()</span><br><span class="line">        <span class="keyword">if</span> len(value) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value cannot be empty or blank'</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>上述的两个例子演示了描述符的典型用途：管理数据属性。这种描述符也叫覆盖型描述符，因为描述符的 <code>__set__</code> 方法使用托管实例中的同名属性覆盖(即插手接管)了要设置的属性。</p><h2 id="20-2-覆盖型与非覆盖型描述符对比"><a href="#20-2-覆盖型与非覆盖型描述符对比" class="headerlink" title="20.2 覆盖型与非覆盖型描述符对比"></a>20.2 覆盖型与非覆盖型描述符对比</h2><h3 id="20-2-1-覆盖型描述符"><a href="#20-2-1-覆盖型描述符" class="headerlink" title="20.2.1 覆盖型描述符"></a>20.2.1 覆盖型描述符</h3><p>实现 <code>__set__</code> 方法的描述符属于覆盖型描述符，因为虽然描述符是类属性，但是实现 <code>__set__</code> 方法的话，会覆盖对实例属性的赋值操作。</p><h3 id="20-2-2-没有-get-方法的覆盖型描述符"><a href="#20-2-2-没有-get-方法的覆盖型描述符" class="headerlink" title="20.2.2 没有 __get__ 方法的覆盖型描述符"></a>20.2.2 没有 <code>__get__</code> 方法的覆盖型描述符</h3><p>此时，只有写操作由描述符处理。通过实例读取描述符会返回描述符对象本身，因为没有处理读操作的 <code>__get__</code> 方法。如果直接通过实例的 <code>__dict__</code> 属性创建同名实例属性，以后再设置那个属性时，仍会由 <code>__set__</code> 方法插手接管，但是读取那个属性的话，就会直接从实例中返回新赋予的值，而不会返回描述符对象。</p><h3 id="20-2-3-非覆盖型描述符"><a href="#20-2-3-非覆盖型描述符" class="headerlink" title="20.2.3 非覆盖型描述符"></a>20.2.3 非覆盖型描述符</h3><p>没有实现 <code>__set__</code> 方法的描述符是非覆盖型描述符。如果设置了同名的实例属性，描述符会被遮盖，致使描述符无法处理那个实例的那个属性。</p><h2 id="20-3-方法是描述符"><a href="#20-3-方法是描述符" class="headerlink" title="20.3 方法是描述符"></a>20.3 方法是描述符</h2><p>在类中定义的函数属于绑定方法(bound method)，因为用户定义的函数都有 <code>__get__</code> 方法，所以依附到类上时，就相当于描述符。</p><p>描述符一样，通过托管类访问时，函数的 <code>__get__</code> 方法会返回自身的引用。但是，通过实例访问时，函数的 <code>__get__</code> 方法返回的是绑定方法对象：一种可调用的对象，里面包装着函数，并把托管实例(例如 obj)绑定给函数的第一个参数(即 self)。</p><p>下面我们来测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span><span class="params">(collections.UserString)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Text(&#123;!r&#125;)'</span>.format(self.data)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> self[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; word = Text(&apos;forward&apos;) </span><br><span class="line">&gt;&gt;&gt; word</span><br><span class="line">Text(&apos;forward&apos;)</span><br><span class="line">&gt;&gt;&gt; word.reverse()</span><br><span class="line">Text(&apos;drawrof&apos;)</span><br><span class="line">&gt;&gt;&gt; Text.reverse(Text(&apos;backward&apos;))</span><br><span class="line">Text(&apos;drawkcab&apos;)</span><br><span class="line">&gt;&gt;&gt; type(Text.reverse), type(word.reverse)</span><br><span class="line">(&lt;class &apos;function&apos;&gt;, &lt;class &apos;method&apos;&gt;)</span><br><span class="line">&gt;&gt;&gt; list(map(Text.reverse, [&apos;repaid&apos;, (10, 20, 30), Text(&apos;stressed&apos;)])) [&apos;diaper&apos;, (30, 20, 10), Text(&apos;desserts&apos;)]</span><br><span class="line">&gt;&gt;&gt; Text.reverse.__get__(word)</span><br><span class="line">&lt;bound method Text.reverse of Text(&apos;forward&apos;)&gt;</span><br><span class="line">&gt;&gt;&gt; Text.reverse.__get__(None, Text)</span><br><span class="line">&lt;function Text.reverse at 0x101244e18&gt;</span><br><span class="line">&gt;&gt;&gt; word.reverse</span><br><span class="line">&lt;bound method Text.reverse of Text(&apos;forward&apos;)&gt;</span><br><span class="line">&gt;&gt;&gt; word.reverse.__self__ # 绑定方法对象有个 __self__ 属性，其值是调用这个方法的实例引用。</span><br><span class="line">Text(&apos;forward&apos;)</span><br><span class="line">&gt;&gt;&gt; word.reverse.__func__ is Text.reverse</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h2 id="20-4-描述符用法建议"><a href="#20-4-描述符用法建议" class="headerlink" title="20.4 描述符用法建议"></a>20.4 描述符用法建议</h2><ul><li>使用特性来创建只读属性：创建只读属性最简单的方式是使用特性，没必要再自定义一个描述符</li><li>只读描述符必须有 <code>__set__</code> 方法：如果使用描述符类实现只读属性，要记住，<code>__get__</code> 和 <code>__set__</code> 两个方法必须都定义，否则，实例的同名属性会遮盖描述符。</li><li>用于验证的描述符可以只有 <code>__set__</code> 方法：对仅用于验证的描述符来说，<code>__set__</code> 方法应该检查 value 参数获得的值，如果有效，使用描述符实例的名称为键，直接在实例的 <code>__dict__</code> 属性中设置。</li><li>仅有 <code>__get__</code> 方法的描述符可以实现高效缓存：如果只编写了 <code>__get__</code> 方法，那么创建的是非覆盖型描述符。这种描述符可用于执行某些耗费资源的计算，然后为实例设置同名属性，缓存结果。同名实例属性会遮盖描述符，因此后续访问会直接从实例的 <code>__dict__</code> 属性中获取值，而不会再触发描述符的 <code>__get__</code> 方法。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;描述符是对多个属性运用相同存取逻辑的一种方式，是实现了特定协议的类，这个协议包括 &lt;code&gt;__get__&lt;/code&gt;、&lt;code&gt;__set__&lt;/code&gt; 和 &lt;code&gt;__delete__&lt;/code&gt; 方法。&lt;/strong&gt;&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="Fluent Python" scheme="https://homholueng.github.io/categories/Fluent-Python/"/>
    
    
      <category term="Python" scheme="https://homholueng.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 19 - 动态属性和特性</title>
    <link href="https://homholueng.github.io/2019/10/17/fluent-python-dynamic-attribute-and-property/"/>
    <id>https://homholueng.github.io/2019/10/17/fluent-python-dynamic-attribute-and-property/</id>
    <published>2019-10-17T02:24:43.000Z</published>
    <updated>2019-10-17T02:24:43.790Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>特性至关重要的地方在于，特性的存在使得开发者可以非常安全并且确定可行地将公共数据属性作为类的公共接口的一部分开放出来。</p></blockquote><h3 id="19-1-3-使用-new-方法以灵活的方式创建对象"><a href="#19-1-3-使用-new-方法以灵活的方式创建对象" class="headerlink" title="19.1.3　使用 __new__ 方法以灵活的方式创建对象"></a>19.1.3　使用 <code>__new__</code> 方法以灵活的方式创建对象</h3><p>我们通常把 <code>__init__</code> 称为构造方法，这是从其他语言借鉴过来的术语。其实，用于构建实例的是特殊方法 <code>__new__</code>：这是个类方法（使用特殊方式处理，因此不必使用 <code>@classmethod</code> 装饰器），必须返回一个实例。返回的实例会作为第一个参数（即 self）传给 <code>__init__</code> 方法。因为调用 <code>__init__</code> 方法时要传入实例，而且禁止返回任何值，所以 <code>__init__</code> 方法其实是“初始化方法”。真正的构造方法是 <code>__new__</code>。我们几乎不需要自己编写 <code>__new__</code> 方法，因为从 object 类继承的实现已经足够了。</p><p>刚才说明的过程，即从 <code>__new__</code> 方法到 <code>__init__</code> 方法，是最常见的，但不是唯一的。<code>__new__</code> 方法也可以返回其他类的实例，此时，解释器不会调用 <code>__init__</code> 方法。</p><h3 id="19-1-4-shelve-模块"><a href="#19-1-4-shelve-模块" class="headerlink" title="19.1.4 shelve 模块"></a>19.1.4 shelve 模块</h3><p>标准库中有个 shelve（架子）模块，这名字听起来怪怪的，可是如果知道 pickle（泡菜）是 Python 对象序列化格式的名字，还是在那个格式与对象之间相互转换的某个模块的名字，就会觉得以 shelve 命名是合理的。泡菜坛子摆放在架子上，因此 shelve 模块提供了 pickle 存储方式。</p><p><code>shelve.open</code> 高阶函数返回一个 <code>shelve.Shelf</code> 实例，这是简单的键 值对象数据库，背后由 dbm 模块支持，具有下述特点：</p><ul><li><code>shelve.Shelf</code> 是 <code>abc.MutableMapping</code> 的子类，因此提供了处理映射类型的重要方法。</li><li><code>shelve.Shelf</code> 类还提供了几个管理 I/O 的方法，如 sync 和 close；它也是一个上下文管理器。</li><li>只要把新值赋予键，就会保存键和值。</li><li>键必须是字符串。</li><li>值必须是 pickle 模块能处理的对象。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"></span><br><span class="line">db = shelve.open(DB_NAME)</span><br><span class="line">db[key] = SomeObject()</span><br><span class="line"></span><br><span class="line">obj = db[key]</span><br></pre></td></tr></table></figure><h3 id="19-1-5-使用特性获取链接的记录"><a href="#19-1-5-使用特性获取链接的记录" class="headerlink" title="19.1.5 使用特性获取链接的记录"></a>19.1.5 使用特性获取链接的记录</h3><h4 id="防止实例属性覆盖类属性"><a href="#防止实例属性覆盖类属性" class="headerlink" title="防止实例属性覆盖类属性"></a>防止实例属性覆盖类属性</h4><p>在使用特性时，如果我们要使用对象的类属性，为了防止对象的实例属性覆盖掉我们对雷属性的访问，建议按照以下的方式访问类属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attr</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__class__.some_attr</span><br></pre></td></tr></table></figure><h4 id="使用特性覆盖类的实例属性"><a href="#使用特性覆盖类的实例属性" class="headerlink" title="使用特性覆盖类的实例属性"></a>使用特性覆盖类的实例属性</h4><p>我们可以使用特性覆盖我们实例中的某些属性，但是，当我们要在类中访问实例的属性时，就需要按照如下方式进行访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attr</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__dict__[<span class="string">'attr'</span>]</span><br></pre></td></tr></table></figure><h2 id="19-2-使用特性验证属性"><a href="#19-2-使用特性验证属性" class="headerlink" title="19.2 使用特性验证属性"></a>19.2 使用特性验证属性</h2><h3 id="19-2-2-能验证值的特性"><a href="#19-2-2-能验证值的特性" class="headerlink" title="19.2.2 能验证值的特性"></a>19.2.2 能验证值的特性</h3><p>下面所展示的类使用 property 来向外暴露内部的属性，并且防止用户将属性设置为非法的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight  <span class="comment"># 在这里就使用了 setter 来赋值</span></span><br><span class="line">        self.price = price</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtoal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__weight  <span class="comment"># 真正存储值的地方</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @weight.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            self.__weight = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br></pre></td></tr></table></figure><h2 id="19-3-特性全解析"><a href="#19-3-特性全解析" class="headerlink" title="19.3 特性全解析"></a>19.3 特性全解析</h2><p>虽然内置的 property 经常用作装饰器，但它其实是一个类。property 构造方法的完整签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">property(fget=<span class="literal">None</span>, fset=<span class="literal">None</span>, fdel=<span class="literal">None</span>, doc=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>经典的特性设置方式其实是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_weight</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_weight</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    weight = property(get_weight, set_weight)</span><br></pre></td></tr></table></figure><p>而且，我们知道实例属性会覆盖类属性，虽然特性是类属性，<strong>但是实例属性并不会覆盖类的特性</strong>。</p><p>虽然特性是个强大的功能，不过有时更适合使用简单的或底层的替代方案。</p><h2 id="19-6-处理属性的重要属性和函数"><a href="#19-6-处理属性的重要属性和函数" class="headerlink" title="19.6 处理属性的重要属性和函数"></a>19.6 处理属性的重要属性和函数</h2><h3 id="19-6-1-影响属性处理方式的特殊属性"><a href="#19-6-1-影响属性处理方式的特殊属性" class="headerlink" title="19.6.1 影响属性处理方式的特殊属性"></a>19.6.1 影响属性处理方式的特殊属性</h3><ul><li><code>__class__</code>：对象所属类的引用（即 <code>obj.__class__</code> 与 <code>type(obj)</code> 的作用相同）。Python 的某些特殊方法，例如 <code>__getattr__</code>，只在对象的类中寻找，而不在实例中寻找。</li><li><code>__dict__</code>：一个映射，存储对象或类的可写属性。有 <code>__dict__</code> 属性的对象，任何时候都能随意设置新属性。如果类有 <code>__slots__</code> 属性，它的实例可能没有 <code>__dict__</code> 属性。</li><li><code>__slot__</code>：类可以定义这个这属性，限制实例能有哪些属性。</li></ul><h3 id="19-6-2-处理属性的内置函数"><a href="#19-6-2-处理属性的内置函数" class="headerlink" title="19.6.2 处理属性的内置函数"></a>19.6.2 处理属性的内置函数</h3><ul><li><code>dir</code>：列出对象的大多数属性。dir 函数的目的是交互式使用，因此没有提供完整的属性列表，只列出一组“重要的”属性名。</li></ul><h3 id="19-6-3-处理属性的特殊方法"><a href="#19-6-3-处理属性的特殊方法" class="headerlink" title="19.6.3 处理属性的特殊方法"></a>19.6.3 处理属性的特殊方法</h3><ul><li><code>__delattr__(self, name)</code>：只要使用 del 语句删除属性，就会调用这个方法。</li><li><code>__dir__(self)</code>：把对象传给 dir 函数时调用，列出属性。</li><li><code>__getattr__(self, name)</code>：仅当获取指定的属性失败，搜索过 obj、Class 和超类之后调用。</li><li><code>__getattribute__(self, name)</code>：尝试获取指定的属性时总会调用这个方法，不过，寻找的属性是特殊属性或特殊方法时除外。</li><li><code>__setattr__(self, name, value)</code>：尝试设置指定的属性时总会调用这个方法。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;特性至关重要的地方在于，特性的存在使得开发者可以非常安全并且确定可行地将公共数据属性作为类的公共接口的一部分开放出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;19-1-3-使用-new-方法以灵活的方式创建对象&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Fluent Python" scheme="https://homholueng.github.io/categories/Fluent-Python/"/>
    
    
      <category term="Python" scheme="https://homholueng.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 18 - 使用 asyncio 包处理并发</title>
    <link href="https://homholueng.github.io/2019/10/08/fluent-python-asyncio/"/>
    <id>https://homholueng.github.io/2019/10/08/fluent-python-asyncio/</id>
    <published>2019-10-08T13:23:35.000Z</published>
    <updated>2019-10-08T13:23:35.204Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>并发是指同时处理多件事</p><p>并行是指同时做多件事</p><p>二者不同，但是有联系</p><p>一个关于结构，一个关于执行</p><p>并发用于指定方案，用来解决可能（但未必）并行的问题</p><p>—— Rob Pike（Go 语言创造者之一）</p></blockquote><h2 id="18-1-线程与协程对比"><a href="#18-1-线程与协程对比" class="headerlink" title="18.1 线程与协程对比"></a>18.1 线程与协程对比</h2><p>在编写使用线程来编写程序时，我们需要使用锁来保护程序中重要的部分。而协程默认会做好全方位保护，以防止中断。我们必须显式产出才能让程序的余下部分运行。对协程来说，无需保留锁，在多个线程之间同步操作，协程自身就会同步，因为在任意时刻只有一个协程运行。</p><h3 id="18-1-1-asyncio-Future：故意不阻塞"><a href="#18-1-1-asyncio-Future：故意不阻塞" class="headerlink" title="18.1.1　asyncio.Future：故意不阻塞"></a>18.1.1　asyncio.Future：故意不阻塞</h3><p><code>asyncio.Future</code> 类的 <code>.result()</code> 方法没有参数，因此不能指定超时时间。此外，如果调用 <code>.result()</code> 方法时期物还没运行完毕，那么 <code>.result()</code> 方法不会阻塞去等待结果，而是抛出 asyncio.InvalidStateError` 异常。</p><p>然而，获取 <code>asyncio.Future</code> 对象的结果通常使用 yield from，从中产出结果。使用 <code>yield from</code> 处理期物，等待期物运行完毕这一步无需我们关心，而且不会阻塞事件循环，因为在 asyncio 包中，<code>yield from</code> 的作用是把控制权还给事件循环。</p><h3 id="18-1-2-从期物、任务和协程中产出"><a href="#18-1-2-从期物、任务和协程中产出" class="headerlink" title="18.1.2　从期物、任务和协程中产出"></a>18.1.2　从期物、任务和协程中产出</h3><p>在 asyncio 包中，期物和协程关系紧密，因为可以使用 <code>yield from</code> 从 <code>asyncio.Future</code> 对象中产出结果。这意味着，如果 foo 是协程函数（调用后返回协程对象），抑或是返回 Future 或 Task 实例的普通函数，那么可以这样写：<code>res = yield from foo()</code>。这是 asyncio 包的 API 中很多地方可以互换协程与期物的原因之一。</p><p>为了执行这些操作，必须排定协程的运行时间，然后使用 <code>asyncio.Task</code> 对象包装协程。对协程来说，获取 Task 对象有两种主要方式：</p><ul><li><code>asyncio.async(coro_or_future, *, loop=None)</code>：这个函数统一了协程和期物：第一个参数可以是二者中的任何一个。如果是 Future 或 Task 对象，那就原封不动地返回。如果是协程，那么 async 函数会调用 <code>loop.create_task(...)</code> 方法创建 Task 对象。<code>loop=</code> 关键字参数是可选的，用于传入事件循环；如果没有传入，那么 async 函数会通过调用 <code>asyncio.get_event_loop()</code> 函数获取循环对象。</li><li><code>BaseEventLoop.create_task(coro)</code>：这个方法排定协程的执行时间，返回一个 <code>asyncio.Task</code> 对象。</li></ul><p>在 asyncio 包的文档中，“18.5.3. Tasks and coroutines”一节(<a href="https://docs.python.org/3/library/asyncio-task.html)说明了协程、期物和任务之间的关系。" target="_blank" rel="noopener">https://docs.python.org/3/library/asyncio-task.html)说明了协程、期物和任务之间的关系。</a></p><h2 id="18-2-使用-asyncio-和-aiohttp-包下载"><a href="#18-2-使用-asyncio-和-aiohttp-包下载" class="headerlink" title="18.2　使用 asyncio 和 aiohttp 包下载"></a>18.2　使用 asyncio 和 aiohttp 包下载</h2><p><code>asyncio.wait(...)</code> 协程的参数是一个由期物或协程构成的可迭代对象；wait 会分别把各个协程包装进一个 Task 对象。最终的结果是，wait 处理的所有对象都通过某种方式变成 Future 类的实例。wait 是协程函数，因此返回的是一个协程或生成器对象。</p><p><code>wait_coro</code> 运行结束后返回一个元组，第一个元素是一系列结束的期物，第二个元素是一系列未结束的期物。wait 函数有两个关键字参数，如果设定了可能会返回未结束的期物；这两个参数是 <code>timeout</code> 和 <code>return_when</code>。详情参见 <code>asyncio.wait</code> 函数的文档(<a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait)。" target="_blank" rel="noopener">https://docs.python.org/3/library/asyncio-task.html#asyncio.wait)。</a></p><p>使用 asyncio 包时，我们编写的异步代码中包含由 asyncio 本身驱动的协程（即委派生成器），而生成器最终把职责委托给 asyncio 包或第三方库（如 aiohttp）中的协程。这种处理方式相当于架起了管道，让 asyncio 事件循环（通过我们编写的协程）驱动 执行低层异步 I/O 操作的库函数。</p><h2 id="18-3-避免阻塞型调用"><a href="#18-3-避免阻塞型调用" class="headerlink" title="18.3　避免阻塞型调用"></a>18.3　避免阻塞型调用</h2><p>有两种方法能避免阻塞型调用中止整个应用程序的进程：</p><ul><li><p>在单独的线程中运行各个阻塞型操作</p></li><li><p>把每个阻塞型操作转换成非阻塞的异步调用使用</p></li></ul><p>多个线程是可以的，但是各个操作系统线程（Python 使用的是这种线程）消耗的内存达兆字节（具体的量取决于操作系统种类）。如果要处理几千个连接，而每个连接都使用一个线程的话，我们负担不起。</p><p>为了降低内存的消耗，通常使用回调来实现异步调用。这是一种底层概念，类似于所有并发机制中最古老、最原始的那种——硬件中断。使用回调时，我们不等待响应，而是注册一个函数，在发生某件事时调用。这样，所有调用都是非阻塞的。</p><h2 id="18-4-改进-asyncio-下载脚本"><a href="#18-4-改进-asyncio-下载脚本" class="headerlink" title="18.4　改进 asyncio 下载脚本"></a>18.4　改进 asyncio 下载脚本</h2><p><code>asyncio.Semaphore</code> 对象维护着一个内部计数器，若在对象上调用 <code>.acquire()</code> 协程方法，计数器则递减；若在对象上调用 <code>.release()</code> 协程方法，计数器则递增。计数器的初始值在实例化 Semaphore 时设定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphore = asyncio.Semaphore(concur_req)</span><br></pre></td></tr></table></figure><p>如果计数器大于零，那么调用 <code>.acquire()</code> 方法不会阻塞；可是，如果计数器为零，那么 <code>.acquire()</code> 方法会阻塞调用这个方法的协程，直到其他协程在同一个 Semaphore 对象上调用 <code>.release()</code> 方法，让计数器递增。</p><p>使用 <code>with</code> 语句能够完成上述两种操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (<span class="keyword">yield</span> <span class="keyword">from</span> semaphore):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="18-4-2-使用Executor对象，-防止阻塞事件循环"><a href="#18-4-2-使用Executor对象，-防止阻塞事件循环" class="headerlink" title="18.4.2　使用Executor对象， 防止阻塞事件循环"></a>18.4.2　使用Executor对象， 防止阻塞事件循环</h3><p>asyncio 的事件循环在背后维护着一个 ThreadPoolExecutor 对象，我们可以调用 <code>run_in_executor</code> 方法，把可调用的对象发给它执行，避免某些方法的调用阻塞整个事件循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_in_executor(<span class="literal">None</span>, io_function, *args, **kwargs) <span class="comment"># 第一个参数是 Executor 实例；如果设为 None，使用事件循环的默认 ThreadPoolExecutor 实例</span></span><br></pre></td></tr></table></figure><h2 id="18-5-从回调到期物和协程"><a href="#18-5-从回调到期物和协程" class="headerlink" title="18.5　从回调到期物和协程"></a>18.5　从回调到期物和协程</h2><p>Python 中的回调地狱：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage1</span><span class="params">(response1)</span>:</span> </span><br><span class="line">    request2 = step1(response1) </span><br><span class="line">    api_call2(request2, stage2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage2</span><span class="params">(response2)</span>:</span> </span><br><span class="line">    request3 = step2(response2) </span><br><span class="line">    api_call3(request3, stage3)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage3</span><span class="params">(response3)</span>:</span> </span><br><span class="line">    step3(response3)</span><br><span class="line"></span><br><span class="line">api_call1(request1, stage1)</span><br></pre></td></tr></table></figure><p>上述例子中组织代码的方式导致代码难以阅读，也更难编写：每个函数做一部分工作，设置下一个回调，然后返回，让事件循环继续运行。这样，所有本地的上下文都会丢失。执行下一个回调时（例如 stage2），就无法获取 request2 的值。如果需要那个值，那就必须依靠闭包，或者把它存储在外部数据结构中，以便在处理过程的不同 阶段使用。</p><p>在这个问题上，协程能发挥很大的作用。在协程中，如果要连续执行 3 个异步操作，只需使用 <code>yield</code> 3 次，让事件循环继续运行。3 次操作都在同一个函数定义体中，像是顺序代码，能在处理过程中使用局部变量保留整个任务的上下文：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three_stages</span><span class="params">(request1)</span>:</span> </span><br><span class="line">    response1 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call1(request1) </span><br><span class="line">    <span class="comment"># 第一步 </span></span><br><span class="line">    request2 = step1(response1) </span><br><span class="line">    response2 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call2(request2) </span><br><span class="line">    <span class="comment"># 第二步 </span></span><br><span class="line">    request3 = step2(response2) </span><br><span class="line">    response3 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call3(request3) </span><br><span class="line">    <span class="comment"># 第三步 </span></span><br><span class="line">    step3(response3)</span><br><span class="line"></span><br><span class="line">loop.create_task(three_stages(request1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须显式调度执行</span></span><br></pre></td></tr></table></figure><p>如果这时候还需要为每一步可能发生的错误编写处理逻辑，那么第二种方式带来的好处就更为明显。传统的回调方式需要传入错误处理函数，导致代码阅读难度更大；而使用协程，我们只需要简单的使用 <code>try ··· except</code> 块来处理即可。</p><p>这么做比陷入回调地狱好多了，但是我不会把这种方式称为协程天堂，毕竟我们还要付出代价。我们不能使用常规的函数，必须使用协程，而且要习惯 <code>yield from</code>。另外，我们必 须使用事件循环显式排定协程的执行时间，或者在其他排定了执行时间的协程中使用 <code>yield from</code> 表达式把它激活。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;并发是指同时处理多件事&lt;/p&gt;
&lt;p&gt;并行是指同时做多件事&lt;/p&gt;
&lt;p&gt;二者不同，但是有联系&lt;/p&gt;
&lt;p&gt;一个关于结构，一个关于执行&lt;/p&gt;
&lt;p&gt;并发用于指定方案，用来解决可能（但未必）并行的问题&lt;/p&gt;
&lt;p&gt;—— Rob Pike（Go 
      
    
    </summary>
    
      <category term="Fluent Python" scheme="https://homholueng.github.io/categories/Fluent-Python/"/>
    
    
      <category term="Python" scheme="https://homholueng.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 17 - 使用期物处理并发</title>
    <link href="https://homholueng.github.io/2019/10/06/fluent-python-future-in-parallel/"/>
    <id>https://homholueng.github.io/2019/10/06/fluent-python-future-in-parallel/</id>
    <published>2019-10-06T09:15:18.000Z</published>
    <updated>2019-10-08T13:22:59.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="17-1-2-concurrent-futures-模块"><a href="#17-1-2-concurrent-futures-模块" class="headerlink" title="17.1.2 concurrent.futures 模块"></a>17.1.2 concurrent.futures 模块</h3><p><code>concurrent.futures</code> 模块的主要特色是 ThreadPoolExecutor 和 ProcessPoolExecutor 类，这两个类实现的接口能分别在不同的线程或进程中执行可调用的对象。这两个类在内部维护着一个工作线程或进程池，以及要执行的任务队列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> futures.ThredPoolExecutor(worker_count) <span class="keyword">as</span> executor:</span><br><span class="line">    res = executor.map(download, address_list)</span><br></pre></td></tr></table></figure><p>在上面代码展示的例子中，<code>executor.__exist__</code> 方法糊调用 <code>executor.shutdown(wait=True)</code> 方法，它会在所有线程都执行完毕前阻塞主线程。</p><h3 id="17-1-3-期物"><a href="#17-1-3-期物" class="headerlink" title="17.1.3 期物"></a>17.1.3 期物</h3><p>从 Python 3.4 起，标准库中有两个名为 Future 的类：<code>concurrent.futures.Future</code> 和 <code>asyncio.Future</code>。这两个类的作用相同：两个 Future 类的实例都表示可能已经完成或者尚未完成的 延迟计算。这与 Twisted 引擎中的 Deferred 类、Tornado 框架中的 Future 类，以及多个 JavaScript 库中的 Promise 对象类似。</p><p>期物封装待完成的操作，可以放入队列，完成的状态可以查询，得到结果（或抛出异常）后可以获取结果（或异常）。</p><p>我们要记住一件事：<strong>通常情况下自己不应该创建期物，而只能由并发框架（concurrent.futures 或 asyncio）实例化。原因很简单：期物表示终将发生的事情，而确定某件事会发生的唯一方式是执行的时间已经排定。</strong></p><p>上述两种期物所拥有的下列方法比较在日常使用中会经常用到：</p><ul><li><code>.done()</code>：这个方法不阻塞，返回值是布尔值，指明期物链接的可调用对象是否已经执行。</li><li><code>.add_done_callback()</code>：这个方法只有一个参数，类型是可调用的对象，期物运行结束后会调用指定的可调用对象。</li><li><code>.result()</code>：在期物运行结束后调用的话，这个方法 在两个 Future 类中的作用相同：返回可调用对象的结果，或者重新抛出执行可调用的对象时抛出的异常。可是，如果期物没有运行结束，result 方法在两个 Future 类中的行为相差很大：<ul><li><code>concurrency.futures.Future</code>：result 的调用会阻塞调用方所在的线程，直到有结果可返回。此时，result 方法可以接收可选的 timeout 参数，如果在指定的时间内期物没有运行完毕，会抛出 TimeoutError 异常。</li><li><code>asyncio.Future</code>：result 方法不支持设定超时时间，在这个库中获取期物的结果最好使用 <code>yield from</code> 结构。</li></ul></li></ul><h2 id="17-2-阻塞型I-O和GIL"><a href="#17-2-阻塞型I-O和GIL" class="headerlink" title="17.2　阻塞型I/O和GIL"></a>17.2　阻塞型I/O和GIL</h2><p>CPython 解释器本身就不是线程安全的，因此有全局解释器锁（GIL）， 一次只允许使用一个线程执行 Python 字节码。因此，一个 Python 进程通常不能同时使用多个 CPU 核心。</p><p>然而，标准库中所有执行阻塞型 I/O 操作的函数，在等待操作系统返回结果时都会释放 GIL。这意味着在 Python 语言这个层次上可以使用多线程，而 I/O 密集型 Python 程序能从中受益：一个 Python 线程等待网络响应时，阻塞型 I/O 函数会释放 GIL，再运行一个线程。</p><h2 id="17-3-使用-concurrent-futures-模块启动进程"><a href="#17-3-使用-concurrent-futures-模块启动进程" class="headerlink" title="17.3 使用 concurrent.futures 模块启动进程"></a>17.3 使用 concurrent.futures 模块启动进程</h2><p>ProcessPoolExecutor 和 ThreadPoolExecutor 类都实现了通用的 Executor 接口，如果需要做 CPU 密集型处理，使用这个模块能绕开 GIL，利用所有可用的 CPU 核心。</p><blockquote><p>如果使用 Python 处理 CPU 密集型工作，应该试试 PyPy（<a href="http://pypy.org）。" target="_blank" rel="noopener">http://pypy.org）。</a></p></blockquote><h2 id="17-4-实验-Executor-map-方法"><a href="#17-4-实验-Executor-map-方法" class="headerlink" title="17.4 实验 Executor.map 方法"></a>17.4 实验 Executor.map 方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>), end=<span class="string">' '</span>)</span><br><span class="line">    print(*args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loiter</span><span class="params">(n)</span>:</span></span><br><span class="line">    msg = <span class="string">'&#123;&#125;loiter(&#123;&#125;): doing nothing for &#123;&#125;s...'</span></span><br><span class="line">    display(msg.format(<span class="string">'\t'</span> * n, n, n))</span><br><span class="line">    sleep(n)</span><br><span class="line">    msg = <span class="string">'&#123;&#125;loiter(&#123;&#125;): done.'</span></span><br><span class="line">    display(msg.format(<span class="string">'\t'</span> * n, n))</span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    display(<span class="string">'Script starting.'</span>)</span><br><span class="line">    executor = futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line">    results = executor.map(loiter, range(<span class="number">5</span>))</span><br><span class="line">    display(<span class="string">'results:'</span>, results)</span><br><span class="line">    display(<span class="string">'Waiting for individual results:'</span>)</span><br><span class="line">    <span class="keyword">for</span> i, result <span class="keyword">in</span> enumerate(results):</span><br><span class="line">        display(<span class="string">'result &#123;&#125;: &#123;&#125;'</span>.format(i, result))</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>上述程序输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[16:57:09] Script starting.</span><br><span class="line">[16:57:09] loiter(0): doing nothing for 0s...</span><br><span class="line">[16:57:09] loiter(0): done.</span><br><span class="line">[16:57:09]      loiter(1): doing nothing for 1s...</span><br><span class="line">[16:57:09]              loiter(2): doing nothing for 2s...</span><br><span class="line">[16:57:09] results: &lt;generator object Executor.map.&lt;locals&gt;.result_iterator at 0x10d21f258&gt;</span><br><span class="line">[16:57:09]                      loiter(3): doing nothing for 3s...</span><br><span class="line">[16:57:09] Waiting for individual results:</span><br><span class="line">[16:57:09] result 0: 0</span><br><span class="line">[16:57:10]      loiter(1): done.</span><br><span class="line">[16:57:10]                              loiter(4): doing nothing for 4s...</span><br><span class="line">[16:57:10] result 1: 10</span><br><span class="line">[16:57:11]              loiter(2): done.</span><br><span class="line">[16:57:11] result 2: 20</span><br><span class="line">[16:57:12]                      loiter(3): done.</span><br><span class="line">[16:57:12] result 3: 30</span><br><span class="line">[16:57:14]                              loiter(4): done.</span><br><span class="line">[16:57:14] result 4: 40</span><br></pre></td></tr></table></figure><p>Executor.map 函数易于使用，不过有个特性需要注意：<strong>这个函数返回结果的顺序与调用开始的顺序一致。如果第一个调用生成结果用时 10 秒，而其他调用只用 1 秒，在获取 map 方法返回的生成器产出的第一个结果时代码会阻塞 10 秒。在此之后，获取后续结果时不会阻塞，因为后续的调用已经结束。</strong></p><blockquote><p><code>executor.submit</code> 和 <code>futures.as_completed</code> 这个组合比 <code>executor.map</code> 更灵活，因为 submit 方法能处理不同的可调用对 象和参数，而 <code>executor.map</code> 只能处理参数不同的同一个可调用对象。此外，传给 <code>futures.as_completed</code> 函数的期物集合可以来 自多个 Executor 实例</p></blockquote><h2 id="17-5-显示下载进度并处理错误"><a href="#17-5-显示下载进度并处理错误" class="headerlink" title="17.5　显示下载进度并处理错误"></a>17.5　显示下载进度并处理错误</h2><p>使用 TQDM 包 （<a href="https://github.com/noamraph/tqdm）可以实现的文本动画进度条。" target="_blank" rel="noopener">https://github.com/noamraph/tqdm）可以实现的文本动画进度条。</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">1000</span>)):</span><br><span class="line">    time.sleep(<span class="number">.01</span>)</span><br></pre></td></tr></table></figure><p>随后，进度条会显示在下方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">49%|███████████████████████████████████████████████████████████████▊                                                                  | 491/1000 [00:05&lt;00:05, 87.69it/s]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;17-1-2-concurrent-futures-模块&quot;&gt;&lt;a href=&quot;#17-1-2-concurrent-futures-模块&quot; class=&quot;headerlink&quot; title=&quot;17.1.2 concurrent.futures 模块&quot;&gt;&lt;/a&gt;17
      
    
    </summary>
    
      <category term="Fluent Python" scheme="https://homholueng.github.io/categories/Fluent-Python/"/>
    
    
      <category term="Python" scheme="https://homholueng.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>通识 - 暗网</title>
    <link href="https://homholueng.github.io/2019/09/30/dark-web/"/>
    <id>https://homholueng.github.io/2019/09/30/dark-web/</id>
    <published>2019-09-30T09:41:00.000Z</published>
    <updated>2019-09-30T09:41:38.939Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/09/30/dark-web/dark-web.png" title="[暗网]">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/09/30/dark-web/dark-web.png&quot; title=&quot;[暗网]&quot;&gt;
      
    
    </summary>
    
      <category term="General Knowledge" scheme="https://homholueng.github.io/categories/General-Knowledge/"/>
    
    
      <category term="Dark Web" scheme="https://homholueng.github.io/tags/Dark-Web/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 16 - 协程</title>
    <link href="https://homholueng.github.io/2019/09/05/fluent-python-coroutine/"/>
    <id>https://homholueng.github.io/2019/09/05/fluent-python-coroutine/</id>
    <published>2019-09-05T12:14:56.000Z</published>
    <updated>2019-09-30T09:35:49.645Z</updated>
    
    <content type="html"><![CDATA[<p>字典为动词 “to yield” 给出了两个释义：产出和让步。对于 Python 生成器中的 yield 来说，这两个含义都成立。<code>yield item</code> 这行代码会产出一个值，提供给 <code>next(...)</code> 的调用方；此外，还会作出让步，暂停执行生成器，让调用方继续工作，直到需要使用另一个值时再调用 <code>next()</code>。调用方会从生成器中拉取值。</p><p>yield 关键字甚至还可以不接收或传出数据。不管数据如何流动，yield 都是一种流程控制工具，使用它可以实现协作式多任务：协程可以把控制器让步给中心调度程序，从而激活其他的协程。</p><p>从根本上把 yield 视作控制流程的方式，这样就好理解协程了。</p><h2 id="16-1-生成器如何进化成协程"><a href="#16-1-生成器如何进化成协程" class="headerlink" title="16.1 生成器如何进化成协程"></a>16.1 生成器如何进化成协程</h2><p>协程的底层架构在 “PEP 342—Coroutines via Enhanced Generators”（<a href="https://www.python.org/dev/peps/pep-0342/)中定义，并在" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0342/)中定义，并在</a> Python 2.5（2006年）实现了。自此之后，yield 关键字可以在表达式中使用，而且生成器 API 中增加了 <code>.send(value)</code> 方法。生成器的调用方可以使用 <code>.send(...)</code> 方法发送数据，发送的数据会成为生成器函数中 yield 表达式的值。因此，生成器可以作为协程使用。协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。</p><p>除了 <code>.send(...)</code> 方法，PEP 342 还添加了 <code>.throw(...)</code> 和 <code>.close()</code> 方法：前者的作用是让调用方抛出异常，在生成器中处理；后者的作用是终止生成器。</p><p>协程最近的演进来自 Python 3.3（2012 年）实现的 “PEP 380—Syntax for Delegating to a Subgenerator”（<a href="https://www.python.org/dev/peps/pep0380/)。PEP" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep0380/)。PEP</a> 380 对生成器函数的句法做了两处改动，以便更好地作为协程使用。</p><ul><li>现在，生成器可以返回一个值；以前，如果在生成器中给 return 语句提供值，会抛出 SyntaxError 异常。</li><li>新引入了 yield from 句法，使用它可以把复杂的生成器重构成小型的嵌套生成器，省去了之前把生成器的工作委托给子生成器所需的大量样板代码。</li></ul><h2 id="16-2-用作协程的生成器的基本行为"><a href="#16-2-用作协程的生成器的基本行为" class="headerlink" title="16.2　用作协程的生成器的基本行为"></a>16.2　用作协程的生成器的基本行为</h2><p>下面是一个最简单的协程的演示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="function"><span class="keyword">def</span> <span class="title">simple_coroutine</span><span class="params">()</span>:</span></span><br><span class="line">   ...:     print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line">   ...:     x = <span class="keyword">yield</span></span><br><span class="line">   ...:     print(<span class="string">'-&gt; coroutine received:'</span>, x)</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: my_coro = simple_coroutine()</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: my_coro</span><br><span class="line">Out[<span class="number">3</span>]: &lt;generator object simple_coroutine at <span class="number">0x106cfeaf0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: next(my_coro)</span><br><span class="line">-&gt; coroutine started</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: my_coro.send(<span class="number">42</span>)</span><br><span class="line">-&gt; coroutine received: 42</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">StopIteration                             Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-5</span><span class="number">-7</span>c96f97a77cb&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 my_coro.send(42)</span><br><span class="line"></span><br><span class="line">StopIteration:</span><br></pre></td></tr></table></figure><p>首先，协程使用生成器函数定义，即定义体中含有 yield 关键字，与创建生成器的方式一下，调用函数得到生成器对象；然后调用 next 函数，因为生成器还没启动，没有在 yield 处暂停。调用 send 发送数据后，yield 表达式会计算出发送过去的值，协程恢复执行，一直运行到下一个 yield 表达式或者终止，实例中控制权流到了协程定义体的末尾，导致生成器像往常一样抛出了 StopIteration 异常。</p><p>协程会处于一下四个状态中的其中一个，使用 <code>inspect.getgeneratorstate</code> 能够获取协程的状态：</p><ul><li><code>GEN_CREATED</code>：等待开始执行。</li><li><code>GEN_RUNNING</code>：解释器正在执行。</li><li><code>GEN_SUSPENDED</code>：在 yield 表达式处暂停。</li><li><code>GEN_CLOSED</code>：执行结束。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">6</span>]: <span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: inspect.getgeneratorstate(my_coro)</span><br><span class="line">Out[<span class="number">7</span>]: <span class="string">'GEN_CLOSED'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: my_coro = simple_coroutine()</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: inspect.getgeneratorstate(my_coro)</span><br><span class="line">Out[<span class="number">9</span>]: <span class="string">'GEN_CREATED'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: next(my_coro)</span><br><span class="line">-&gt; coroutine started</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: inspect.getgeneratorstate(my_coro)</span><br><span class="line">Out[<span class="number">11</span>]: <span class="string">'GEN_SUSPENDED'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: my_coro.send(<span class="number">42</span>)</span><br><span class="line">-&gt; coroutine received: 42</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">StopIteration                             Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-12</span><span class="number">-7</span>c96f97a77cb&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 my_coro.send(42)</span><br><span class="line"></span><br><span class="line">StopIteration:</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: inspect.getgeneratorstate(my_coro)</span><br><span class="line">Out[<span class="number">13</span>]: <span class="string">'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure><p>因为 send 方法的参数会成为暂停的 yield 表达式的值，所以，仅当协程处于暂停状态时才能调用 send 方法。</p><p>如果创建协程对象后立即把 <code>None</code> 之外的值发给它，会出现下述错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">14</span>]: my_coro = simple_coroutine()</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: my_coro.send(<span class="number">42</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-15</span><span class="number">-7</span>c96f97a77cb&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 my_coro.send(42)</span><br><span class="line"></span><br><span class="line">TypeError: can<span class="string">'t send non-None value to a just-started generator</span></span><br></pre></td></tr></table></figure><p>最先调用 <code>next(my_coro)</code> 函数这一步通常称为“预激”（prime）协程 （即，让协程向前执行到第一个 yield 表达式，准备好作为活跃的协程使用）。</p><h2 id="16-4-预激协程的装饰器"><a href="#16-4-预激协程的装饰器" class="headerlink" title="16.4　预激协程的装饰器"></a>16.4　预激协程的装饰器</h2><p>如果不预激，那么协程没什么用，为了简化协程的用法，有时会使用一个预激装饰器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">primer</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        gen = func(*args, **kwargs)</span><br><span class="line">        next(gen)</span><br><span class="line">        <span class="keyword">return</span> gen</span><br><span class="line">    <span class="keyword">return</span> primer</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: @coroutine</span><br><span class="line">   ...: <span class="function"><span class="keyword">def</span> <span class="title">simple_coroutine</span><span class="params">()</span>:</span></span><br><span class="line">   ...:     print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line">   ...:     x = <span class="keyword">yield</span></span><br><span class="line">   ...:     print(<span class="string">'-&gt; coroutine received:'</span>, x)</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: gen =simple_coroutine()</span><br><span class="line">-&gt; coroutine started</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: gen.send(<span class="number">42</span>)</span><br><span class="line">-&gt; coroutine received: 42</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">StopIteration                             Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-4</span><span class="number">-72</span>d0e54668c5&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 gen.send(42)</span><br><span class="line"></span><br><span class="line">StopIteration:</span><br></pre></td></tr></table></figure><h2 id="16-5-终止协程和异常处理"><a href="#16-5-终止协程和异常处理" class="headerlink" title="16.5　终止协程和异常处理"></a>16.5　终止协程和异常处理</h2><p>协程中未处理的异常会向上冒泡，传给 next 函数或 send 方法的调用方（即触发协程的对象）。</p><p>这个特性允许我们发送某个哨符值，让协程退出。内置的 <code>None</code> 和 <code>Ellipsis</code> 等常量经常用作哨符值。<code>Ellipsis</code> 的优点是，数据流中不太常有这个值。</p><p>从 Python 2.5 开始，客户代码可以在生成器对象上调用两个方法，显式地把异常发给协程。</p><p>这两个方法是 throw 和 close：</p><ul><li><code>generator.throw(exc_type[, exc_value[, traceback]])</code>：致使生成器在暂停的 yield 表达式处抛出指定的异常。如果生成器处理了抛出的异常，代码会向前执行到下一个 yield 表达式，而产出的值会成为调用 <code>generator.throw</code> 方法得到的返回值。如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上下文中。</li><li><code>generator.close()</code>：致使生成器在暂停的 yield 表达式处抛出 GeneratorExit 异常。 如果生成器没有处理这个异常，或者抛出了 StopIteration 异常（通常是指运行到结尾），调用方不会报错。如果收到 GeneratorExit 异常，生成器一定不能产出值，否则解释器会抛出 RuntimeError 异常。 生成器抛出的其他异常会向上冒泡，传给调用方。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoException</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo_exc_handling</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            x = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">except</span> DemoException:</span><br><span class="line">            print(<span class="string">'*** DemoException handled. Continuing...'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'-&gt; coroutine received: &#123;!r&#125;'</span>.format(x))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">'This line should never run.'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: exc_coro = demo_exc_handling()</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: next(exc_coro)</span><br><span class="line">-&gt; coroutine started</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: exc_coro.send(<span class="number">11</span>)</span><br><span class="line">-&gt; coroutine received: 11</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: exc_coro.send(<span class="number">22</span>)</span><br><span class="line">-&gt; coroutine received: 22</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: exc_coro.throw(DemoException())</span><br><span class="line">*** DemoException handled. Continuing...</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: inspect.getgeneratorstate(exc_coro)</span><br><span class="line">Out[<span class="number">8</span>]: <span class="string">'GEN_SUSPENDED'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: exc_coro.throw(ZeroDivisionError())</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ZeroDivisionError                         Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-9</span>-e03abf340dfc&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 exc_coro.throw(ZeroDivisionError())</span><br><span class="line"></span><br><span class="line">&lt;ipython-input<span class="number">-1</span>-cc1425411a81&gt; <span class="keyword">in</span> demo_exc_handling()</span><br><span class="line">      <span class="number">6</span>     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      <span class="number">7</span>         <span class="keyword">try</span>:</span><br><span class="line">----&gt; 8             x = yield</span><br><span class="line">      <span class="number">9</span>         <span class="keyword">except</span> DemoException:</span><br><span class="line">     <span class="number">10</span>             print(<span class="string">'*** DemoException handled. Continuing...'</span>)</span><br><span class="line"></span><br><span class="line">ZeroDivisionError:</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: inspect.getgeneratorstate(exc_coro)</span><br><span class="line">Out[<span class="number">11</span>]: <span class="string">'GEN_CLOSED'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: exc_coro = demo_exc_handling()</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: next(exc_coro)</span><br><span class="line">-&gt; coroutine started</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: exc_coro.send(<span class="number">22</span>)</span><br><span class="line">-&gt; coroutine received: 22</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: exc_coro.close()</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: inspect.getgeneratorstate(exc_coro)</span><br><span class="line">Out[<span class="number">16</span>]: <span class="string">'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure><h2 id="16-6-让协程返回值"><a href="#16-6-让协程返回值" class="headerlink" title="16.6　让协程返回值"></a>16.6　让协程返回值</h2><p>下面是 averager 协程的不同版本，这一版会返回结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total / count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average)</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: coro_avg = averager()</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: next(coro_avg)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: coro_avg.send(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: coro_avg.send(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: coro_avg.send(<span class="number">35</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: coro_avg.send(<span class="literal">None</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">StopIteration                             Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-7</span>-a9c80bbec98f&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 coro_avg.send(None)</span><br><span class="line"></span><br><span class="line">StopIteration: Result(count=<span class="number">3</span>, average=<span class="number">25.0</span>)</span><br></pre></td></tr></table></figure><p>发送 <code>None</code> 会终止循环，导致协程结束，返回结果。一如既往，生成器对象会抛出 StopIteration 异常。异常对象的 value 属性保存着返回的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: coro_avg = averager()</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: next(coro_avg)</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: coro_avg.send(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: coro_avg.send(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: <span class="keyword">try</span>:</span><br><span class="line">    ...:     coro_avg.send(<span class="literal">None</span>)</span><br><span class="line">    ...: <span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc:</span><br><span class="line">    ...:     result = exc.value</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: result</span><br><span class="line">Out[<span class="number">13</span>]: Result(count=<span class="number">2</span>, average=<span class="number">20.0</span>)</span><br></pre></td></tr></table></figure><p>获取协程的返回值虽然要绕个圈子，但这是 PEP 380 定义的方式，当我们意识到这一点之后就说得通了：yield from 结构会在内部自动捕获 StopIteration 异常。这种处理方式与 for 循环处理 StopIteration 异常的方式一样：循环机制使用用户易于理解的方式处理异常。对 <code>yield from</code> 结构来说，解释器不仅会捕获 StopIteration 异常，还会把 value 属性的值变成 <code>yield from</code> 表达式的值。可惜，我们无法在控制台中使用交互的方式测试这种行为，因为在函数外部使用 <code>yield from</code>（以及 yield）会导致句法出错。</p><h2 id="16-7-使用yield-from"><a href="#16-7-使用yield-from" class="headerlink" title="16.7　使用yield from"></a>16.7　使用yield from</h2><p>首先要知道，<code>yield from</code> 是全新的语言结构。它的作用比 yield 多很 多，因此人们认为继续使用那个关键字多少会引起误解。在其他语言中，类似的结构使用 await 关键字，这个名称好多了，因为它传达了至关重要的一点：在生成器 gen 中使用 <code>yield from subgen()</code> 时，subgen 会获得控制权，把产出的值传给 gen 的调用方，即调用方可以直接控制 subgen。与此同时，gen 会阻塞，等待 subgen 终止。</p><p><code>yield from</code> 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码。有了这个结构，协程可以通过以前不可能的方式委托职责。</p><p>若想使用 <code>yield from</code> 结构，就要大幅改动代码。为了说明需要改动的部分，PEP 380 使用了一些专门的术语：</p><ul><li>委派生成器：包含 <code>yield from &lt;iterable&gt;</code> 表达式的生成器函数。</li><li>子生成器：从 <code>yield from</code> 表达式中 <code>&lt;iterable&gt;</code> 部分获取的生成器。</li><li>调用方：指代调用<strong>委派生成器</strong>的客户端代码。</li></ul><p>下面的代码使用 <code>yield from</code> 计算平均值并输出统计报告：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total / count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 委派生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端代码，即调用方</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key)</span><br><span class="line">        next(group)</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">            group.send(value)</span><br><span class="line">        group.send(<span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    print(results)</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">'girls;kg'</span>: [<span class="number">40.9</span>, <span class="number">38.5</span>, <span class="number">44.3</span>, <span class="number">42.2</span>, <span class="number">45.2</span>, <span class="number">41.7</span>, <span class="number">44.5</span>, <span class="number">38.0</span>, <span class="number">40.6</span>, <span class="number">44.5</span>], </span><br><span class="line">  <span class="string">'girls;m'</span>: [<span class="number">1.6</span>, <span class="number">1.51</span>, <span class="number">1.4</span>, <span class="number">1.3</span>, <span class="number">1.41</span>, <span class="number">1.39</span>, <span class="number">1.33</span>, <span class="number">1.46</span>, <span class="number">1.45</span>, <span class="number">1.43</span>], </span><br><span class="line">  <span class="string">'boys;kg'</span>: [<span class="number">39.0</span>, <span class="number">40.8</span>, <span class="number">43.2</span>, <span class="number">40.8</span>, <span class="number">43.1</span>, <span class="number">38.6</span>, <span class="number">41.4</span>, <span class="number">40.6</span>, <span class="number">36.3</span>], </span><br><span class="line">  <span class="string">'boys;m'</span>: [<span class="number">1.38</span>, <span class="number">1.5</span>, <span class="number">1.32</span>, <span class="number">1.25</span>, <span class="number">1.37</span>, <span class="number">1.48</span>, <span class="number">1.25</span>, <span class="number">1.49</span>, <span class="number">1.46</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(data)</span><br></pre></td></tr></table></figure><p>在上述的例子中，grouper 发送的每个值都会经由 <code>yield from</code> 处理，通过管道传给 averager 实例。grouper 会在 <code>yield from</code> 表达式处暂停，等待 averager 实例处理客户端发来的值。averager 实例运行完毕后，返回的值绑定到 <code>results[key]</code> 上。while 循环会不断创建 averager 实例，处理更多的值。</p><p>而在 main 中，我们把各个 value 传给 grouper。传入的值最终到达 averager 函数中 <code>term = yield</code> 那一行；grouper 永远不知道传入的值是什么。</p><p>最后，把 None 传入 grouper，导致当前的 averager 实例终止，也让 grouper 继续运行，再创建一个 averager 实例，处理下一组值。</p><p>整个过程如下：</p><ul><li>外层 for 循环每次迭代会新建一个 grouper 实例，赋值给 group 变量；group 是委派生成器。</li><li>调用 <code>next(group)</code>，预激委派生成器 grouper，此时进入 <code>while True</code> 循环，调用子生成器 averager 后，在 <code>yield from</code> 表达式处暂停。</li><li>内层 for 循环调用 <code>group.send(value)</code>，直接把值传给子生成器 averager。同时，当前的 grouper 实例（group）在 <code>yield from</code> 表达式处暂停。</li><li>内层循环结束后，group 实例依旧在 <code>yield from</code> 表达式处暂停， 因此，grouper 函数定义体中为 <code>results[key]</code> 赋值的语句还没有执行。</li><li>如果外层 for 循环的末尾没有 <code>group.send(None)</code>，那么 averager 子生成器永远不会终止，委派生成器 group 永远不会再次激活，因此永远不会为 <code>results[key]</code> 赋值。</li><li>外层 for 循环重新迭代时会新建一个 grouper 实例，然后绑定到 group 变量上。前一个 grouper 实例（以及它创建的尚未终止的 averager 子生成器实例）被垃圾回收程序回收。</li></ul><p>main，grouper，averager 的关系就如下图所示：</p><img src="/2019/09/05/fluent-python-coroutine/yield_from.png" title="[yield from]"><h2 id="16-8-yield-from-的意义"><a href="#16-8-yield-from-的意义" class="headerlink" title="16.8　yield from 的意义"></a>16.8　yield from 的意义</h2><p>PEP 380 中对 <code>yield from</code> 行为的说明如下：</p><ul><li>子生成器产出的值都直接传给委派生成器的调用方（即客户端代码）。</li><li>使用 <code>send()</code> 方法发给委派生成器的值都直接传给子生成器。如果 发送的值是 <code>None</code>，那么会调用子生成器的 <code>__next__()</code> 方法。如果发送的值不是 <code>None</code>，那么会调用子生成器的 <code>send()</code> 方法。如 果调用的方法抛出 StopIteration 异常，那么委派生成器恢复运行。任何其他异常都会向上冒泡，传给委派生成器。</li><li>生成器退出时，生成器（或子生成器）中的 <code>return expr</code> 表达式会触发 <code>StopIteration(expr)</code> 异常抛出。</li><li><code>yield from</code> 表达式的值是子生成器终止时传给 StopIteration 异常的第一个参数。</li><li>传入委派生成器的异常，除了 GeneratorExit 之外都传给子生成器的 <code>throw()</code> 方法。如果调用 <code>throw()</code> 方法时抛出 StopIteration 异常，委派生成器恢复运行。StopIteration 之外的异常会向上冒泡，传给委派生成器。</li><li>如果把 GeneratorExit 异常传入委派生成器，或者在委派生成器 上调用 <code>close()</code> 方法，那么在子生成器上调用 <code>close()</code> 方法，如果它有的话。如果调用 <code>close()</code> 方法导致异常抛出，那么异常会向上冒泡，传给委派生成器；否则，委派生成器抛出 GeneratorExit 异常。</li></ul><p>在不考虑在委派生成器上调用 throw 和 close 及子生成器不抛出异常的情况下，<code>RESULT = yield from EXPR</code> 等价于下列代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_i = iter(EXPR) <span class="comment"># 子生成器，因为需要处理可迭代对象，所以调用了 iter 方法，对生成器对象调用 iter 会返回生成器自身</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _y = next(_i)  <span class="comment"># 子生成器产出的值</span></span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">    _r = _e.value  <span class="comment"># 结果</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        _s = <span class="keyword">yield</span> _y  <span class="comment"># 客户端发送过来的值</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _y = _i.send(_s)</span><br><span class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">            _r = _e.value</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">RESULT = _r</span><br></pre></td></tr></table></figure><p>但是，现实情况要复杂一些，因为要处理客户对 <code>.throw(...)</code> 和 <code>.close()</code> 方法的调用，而这两个方法执行的操作必须传入子生成器。 此外，子生成器可能只是纯粹的迭代器，不支持 <code>.throw(...)</code> 和 <code>.close()</code> 方法，因此 <code>yield from</code> 结构的逻辑必须处理这种情况。。如果子生成器实现了这两个方法，而在子生成器内部，这两个方法都会触发异常抛出，这种情况也必须由 <code>yield from</code> 机制处理。调用方可能会无缘无故地让子生成器自己抛出异常，实现 <code>yield from</code> 结构时也必须处理这种情况。最后，为了优化，如果调用方调用 <code>next(...)</code> 函数或 <code>.send(None)</code> 方法，都要转交职责，在子生成器上调用 <code>next(...)</code> 函数；仅当调用方发送的值不是 <code>None</code> 时，才使用子生成器的 <code>.send(...)</code> 方法。</p><p>为了方便对比，下面列出 PEP 380 中扩充 <code>yield from</code> 表达式的完整伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">_i = iter(EXPR)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _y = next(_i)</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">    _r = _e.value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _s = <span class="keyword">yield</span> _y</span><br><span class="line">        <span class="keyword">except</span> GeneratorExit <span class="keyword">as</span> _e:  <span class="comment"># 这一部分用于关闭委派生成器和子生成器。因为子生成器可以是任 何可迭代的对象，所以可能没有 close 方法。</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _m = _i.close</span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _m()</span><br><span class="line">            <span class="keyword">raise</span> _e</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> _e:  <span class="comment"># 这一部分处理调用方通过 .throw(...) 方法传入的异常。同样，子生成器可以是迭代器，从而没有 throw 方法可调用——这种情况会导 致委派生成器抛出异常。</span></span><br><span class="line">            _x = sys.exc_info()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _m = _i.throw</span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                <span class="keyword">raise</span> _e</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 如果子生成器有 throw 方法，调用它并传入调用方发来的异常。子生成器可能会处理传入的异常（然后继续循环）；可能抛出 StopIteration 异常（从中获取结果，赋值给 _r，循环结束）；还可能不处理，而是抛出相同的或不同的异常，向上冒泡，传给委派生成器。</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                   _y = m(*_x)</span><br><span class="line">                <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">                    _r = _e.value</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 如果产出值时没有异常……</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> _s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    _y = next(_i)  <span class="comment"># 如果调用方最后发送的值是 None，在子生成器上调用 next 函数， 否则调用 send 方法。</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    _y = _i.send(_s)</span><br><span class="line">            <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">                _r = _e.value</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">RESULT = _r</span><br></pre></td></tr></table></figure><p>在伪代码的顶部，有行代码（<code>_y = next(_i)</code>）揭示了一个重要的细节：要预激子生成器。这表明，用于自动预激的装饰器与 <code>yield from</code> 结构不兼容。</p><h2 id="16-9-使用协程做离散事件仿真"><a href="#16-9-使用协程做离散事件仿真" class="headerlink" title="16.9 使用协程做离散事件仿真"></a>16.9 使用协程做离散事件仿真</h2><p>离散事件仿真（Discrete Event Simulation，DES）是一种把系统建模成一系列事件的仿真类型。在离散事件仿真中，仿真“钟”向前推进的量不是固定的，而是直接推进到下一个事件模型的模拟时间。假如我们抽象模拟出租车的运营过程，其中一个事件是乘客上车，下一个事件则是乘客下车。</p><p>离散事件仿真能够使用多线程或在单个线程中使用面向事件的编程技 术（例如事件循环驱动的回调或协程）实现。可以说，为了实现连续仿真，在多个线程中处理实时并行的操作更自然。而协程恰好为实现离散事件仿真提供了合理的抽象。</p><blockquote><p>在仿真领域，进程这个术语指代模型中某个实体的活动，与操作系统中的进程无关。仿真系统中的一个进程可以使用操作系统中的一个进程实现，但是通常会使用一个线程或一个协程实现。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>生成器有三种不同的代码编写风格：有传统的拉取式（迭代器）、推送式（计算平均值的示例）、还有任务时。</p></blockquote><p>使用协程做面向事件编程时，协程会不断把控制权让步给主循环，激活并向前运行其他协程，从而执行各个并发活动。这是一种协作式多任务：协程显式自主地把控制权让步给中央调度程序。而多线程实现的是抢占式多任务。调度程序可以在任何时刻暂停线程（即使在执行一个语句的过程中），把控制权让给其他线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字典为动词 “to yield” 给出了两个释义：产出和让步。对于 Python 生成器中的 yield 来说，这两个含义都成立。&lt;code&gt;yield item&lt;/code&gt; 这行代码会产出一个值，提供给 &lt;code&gt;next(...)&lt;/code&gt; 的调用方；此外，还会
      
    
    </summary>
    
      <category term="Fluent Python" scheme="https://homholueng.github.io/categories/Fluent-Python/"/>
    
    
      <category term="Python" scheme="https://homholueng.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 15 - 上下文管理器和 else 块</title>
    <link href="https://homholueng.github.io/2019/08/25/fluent-python-context-and-else/"/>
    <id>https://homholueng.github.io/2019/08/25/fluent-python-context-and-else/</id>
    <published>2019-08-25T09:32:39.000Z</published>
    <updated>2019-09-30T09:35:49.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="15-1-先做这个，再做那个：if-语句之外的-else-块"><a href="#15-1-先做这个，再做那个：if-语句之外的-else-块" class="headerlink" title="15.1　先做这个，再做那个：if 语句之外的 else 块"></a>15.1　先做这个，再做那个：if 语句之外的 else 块</h2><p>for/else、while/else 和 try/else 的语义关系紧密，不过与 if/else 差别很大：</p><ul><li>for：　仅当 for 循环运行完毕时（即 for 循环没有被 break 语句中止）才运行 else 块。</li><li>while：仅当 while 循环因为条件为假值而退出时（即 while 循环没有被 break 语句中止）才运行 else 块。</li><li>try：仅当 try 块中没有异常抛出时才运行 else 块。（注意，else 中抛出的异常不会由前面的 except 子句处理）</li></ul><p>在所有情况下，如果异常或者 return、break 或 continue 语句导致 控制权跳到了复合语句的主块之外，else 子句也会被跳过。</p><h2 id="15-2-上下文管理器和-with-块"><a href="#15-2-上下文管理器和-with-块" class="headerlink" title="15.2　上下文管理器和 with 块"></a>15.2　上下文管理器和 with 块</h2><p>上下文管理器对象存在的目的是管理 with 语句，就像迭代器的存在是为了管理 for 语句一样。</p><p>上下文管理器协议包含 <code>__enter__</code> 和 <code>__exit__</code> 两个方法。with 语句开始运行时，会在上下文管理器对象上调用 <code>__enter__</code> 方法。with 语句运行结束后，会在上下文管理器对象上调用 <code>__exit__</code> 方法，以此扮演 finally 子句的角色。</p><p>不管控制流程以哪种方式退出 with 块，都会在上下文管理器对象上调用 <code>__exit__</code> 方法，而不是在 <code>__enter__</code> 方法返回的对象上调用。</p><p>下面的例子使用一个精心制作的上下文管理器执行操作，以此强调上下文管理器与 <code>__enter__</code> 方法返回的对象之间的区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">5</span>]: <span class="class"><span class="keyword">class</span> <span class="title">LookingGlass</span>:</span></span><br><span class="line">   ...:</span><br><span class="line">   ...:     <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">   ...:         <span class="keyword">import</span> sys</span><br><span class="line">   ...:         self.original_write = sys.stdout.write</span><br><span class="line">   ...:         sys.stdout.write = self.reverse_write</span><br><span class="line">   ...:         <span class="keyword">return</span> <span class="string">'JABBERWOCKY'</span></span><br><span class="line">   ...:</span><br><span class="line">   ...:     <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(self, text)</span>:</span></span><br><span class="line">   ...:         self.original_write(text[::<span class="number">-1</span>])</span><br><span class="line">   ...:</span><br><span class="line">   ...:     <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span></span><br><span class="line">   ...:         <span class="keyword">import</span> sys</span><br><span class="line">   ...:         sys.stdout.write = self.original_write</span><br><span class="line">   ...:         <span class="keyword">if</span> exc_type <span class="keyword">is</span> ZeroDivisionError:</span><br><span class="line">   ...:             print(<span class="string">'Please DO NOT divide by zero!'</span>)</span><br><span class="line">   ...:             <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="keyword">with</span> LookingGlass() <span class="keyword">as</span> what:</span><br><span class="line">   ...:     print(<span class="string">'Alice, Kitty and Snowdrop'</span>)</span><br><span class="line">   ...:     print(what)</span><br><span class="line">   ...:</span><br><span class="line">pordwonS dna yttiK ,ecilA</span><br><span class="line">YKCOWREBBAJ</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: what</span><br><span class="line">Out[<span class="number">7</span>]: <span class="string">'JABBERWOCKY'</span></span><br></pre></td></tr></table></figure><ul><li>如果一切正常，Python 调用 <code>__exit__</code> 方法时传入的参数是 <code>None</code>, <code>None</code>, <code>None</code>；如果抛出了异常，这三个参数是异常数据。<ul><li><code>exc_type</code>：异常类。</li><li><code>exc_value</code>：异常实例。有时会有参数传给异常构造方法，例如错误消息，这些参数可以使用 <code>exc_value.args</code> 获取。</li><li><code>traceback</code>：traceback 对象。</li></ul></li><li>如果 <code>__exit__</code> 方法返回 <code>None</code>，或者 <code>True</code> 之外的值，with 块中的任何异常都会向上冒泡。</li></ul><p>上下文管理器的具体工作方式参见下面的例子。在这个示例中，我们在 with 块之外使用 LookingGlass 类，因此可以手动调用 <code>__enter__</code> 和 <code>__exit__</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: manager = LookingGlass()</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: monster = manager.__enter__()</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: monster == <span class="string">'JABBERWOCKY'</span></span><br><span class="line">Out[<span class="number">10</span>]: eurT</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: monster</span><br><span class="line">Out[<span class="number">11</span>]: <span class="string">'YKCOWREBBAJ'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: manager.__exit__(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: monster</span><br><span class="line">Out[<span class="number">14</span>]: <span class="string">'JABBERWOCKY'</span></span><br></pre></td></tr></table></figure><h2 id="15-3-contextlib-模块中的实用工具"><a href="#15-3-contextlib-模块中的实用工具" class="headerlink" title="15.3　contextlib 模块中的实用工具"></a>15.3　contextlib 模块中的实用工具</h2><h3 id="closing"><a href="#closing" class="headerlink" title="closing"></a>closing</h3><p>如果对象提供了 <code>close()</code> 方法，但没有实现 <code>__enter__</code>/<code>__exit__</code> 协议，那么可以使用这个函数构建上下文管理器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> closing</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> closing(urlopen(<span class="string">'http://www.python.org'</span>)) <span class="keyword">as</span> page:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> page:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><h3 id="suppress"><a href="#suppress" class="headerlink" title="suppress"></a>suppress</h3><p>构建临时忽略指定异常的上下文管理器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> suppress</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> suppress(FileNotFoundError):</span><br><span class="line">    os.remove(<span class="string">'somefile.tmp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> suppress(FileNotFoundError):</span><br><span class="line">    os.remove(<span class="string">'someotherfile.tmp'</span>)</span><br></pre></td></tr></table></figure><p>上面的代码和下面的代码是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.remove(<span class="string">'somefile.tmp'</span>)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.remove(<span class="string">'someotherfile.tmp'</span>)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="contextmanager"><a href="#contextmanager" class="headerlink" title="@contextmanager"></a>@contextmanager</h3><p>这个装饰器把简单的生成器函数变成上下文管理器，这样就不用创建类去实现管理器协议了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">managed_resource</span><span class="params">(*args, **kwds)</span>:</span></span><br><span class="line">    <span class="comment"># Code to acquire resource, e.g.:</span></span><br><span class="line">    resource = acquire_resource(*args, **kwds)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> resource</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># Code to release resource, e.g.:</span></span><br><span class="line">        release_resource(resource)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> managed_resource(timeout=<span class="number">3600</span>) <span class="keyword">as</span> resource:</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># Resource is released at the end of this block,</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># even if code in the block raises an exception</span></span><br></pre></td></tr></table></figure><h3 id="ContextDecorator"><a href="#ContextDecorator" class="headerlink" title="ContextDecorator"></a>ContextDecorator</h3><p>这是个基类，用于定义基于类的上下文管理器。这种上下文管理器也能用于装饰函数，在受管理的上下文中运行整个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> ContextDecorator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontext</span><span class="params">(ContextDecorator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Starting'</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *exc)</span>:</span></span><br><span class="line">        print(<span class="string">'Finishing'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@mycontext()</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'The bit in the middle'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>function()</span><br><span class="line">Starting</span><br><span class="line">The bit <span class="keyword">in</span> the middle</span><br><span class="line">Finishing</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> mycontext():</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'The bit in the middle'</span>)</span><br><span class="line">...</span><br><span class="line">Starting</span><br><span class="line">The bit <span class="keyword">in</span> the middle</span><br><span class="line">Finishing</span><br></pre></td></tr></table></figure><h3 id="ExitStack"><a href="#ExitStack" class="headerlink" title="ExitStack"></a>ExitStack</h3><p>这个上下文管理器能进入多个上下文管理器。with 块结束时，ExitStack 按照后进先出的顺序调用栈中各个上下文管理器的 <code>__exit__</code> 方法。如果事先不知道 with 块要进入多少个上下文管理器，可以使用这个类。例如，同时打开任意一个文件列表中的所有文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> ExitStack() <span class="keyword">as</span> stack:</span><br><span class="line">    files = [stack.enter_context(open(fname)) <span class="keyword">for</span> fname <span class="keyword">in</span> filenames]</span><br><span class="line">    <span class="comment"># All opened files will automatically be closed at the end of</span></span><br><span class="line">    <span class="comment"># the with statement, even if attempts to open files later</span></span><br><span class="line">    <span class="comment"># in the list raise an exception</span></span><br></pre></td></tr></table></figure><h2 id="15-4-使用-contextmanager"><a href="#15-4-使用-contextmanager" class="headerlink" title="15.4　使用 @contextmanager"></a>15.4　使用 @contextmanager</h2><p>其实，<code>contextlib.contextmanager</code> 装饰器会把函数包装成实现 <code>__enter__</code> 和 <code>__exit__</code> 方法的类。</p><p>这个类的 <code>__enter__</code> 方法有如下作用：</p><ol><li>调用生成器函数，保存生成器对象（这里把它称为 gen）。</li><li>调用 <code>next(gen)</code>，执行到 yield 关键字所在的位置。</li><li>返回 <code>next(gen)</code> 产出的值，以便把产出的值绑定到 with/as 语句中的目标变量上。</li></ol><p>with 块终止时，<code>__exit__</code> 方法会做一下几件事：</p><ol><li>检查有没有把异常传给 <code>exc_type</code>；如果有，调用 <code>gen.throw(exception)</code>，在生成器函数定义体中包含 yield 关键字的那一行抛出异常。</li><li>否则，用 <code>next(gen)</code>，继续执行生成器函数定义体中 yield 语句之后的代码。</li></ol><blockquote><p>使用 @contextmanager 装饰器时，要把 yield 语句放在 try/finally 语句中（或者放在 with 语句中），这是无法避免的，因为我们永远不知道上下文管理器的用户会在 with 块中做什么。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;15-1-先做这个，再做那个：if-语句之外的-else-块&quot;&gt;&lt;a href=&quot;#15-1-先做这个，再做那个：if-语句之外的-else-块&quot; class=&quot;headerlink&quot; title=&quot;15.1　先做这个，再做那个：if 语句之外的 else 块&quot;&gt;
      
    
    </summary>
    
      <category term="Fluent Python" scheme="https://homholueng.github.io/categories/Fluent-Python/"/>
    
    
      <category term="Python" scheme="https://homholueng.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 14 - 可迭代的对象、迭代器和生成器</title>
    <link href="https://homholueng.github.io/2019/08/25/fluent-python-iter/"/>
    <id>https://homholueng.github.io/2019/08/25/fluent-python-iter/</id>
    <published>2019-08-25T08:21:37.000Z</published>
    <updated>2019-08-27T13:35:34.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="14-1-Sentence-类第1版：单词序列"><a href="#14-1-Sentence-类第1版：单词序列" class="headerlink" title="14.1　Sentence 类第1版：单词序列"></a>14.1　Sentence 类第1版：单词序列</h2><p>我们要实现一个 Sentence 类，以此打开探索可迭代对象的旅程。我们向这个类的构造方法传入包含一些文本的字符串，然后可以逐个单词迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.words[index]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.words)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br></pre></td></tr></table></figure><p>注意，<code>reprlib.repr</code> 这个实用函数用于生成大型数据结构的简略字符串表示。</p><h3 id="序列可以迭代的原因：iter函数"><a href="#序列可以迭代的原因：iter函数" class="headerlink" title="序列可以迭代的原因：iter函数"></a>序列可以迭代的原因：iter函数</h3><p>解释器需要迭代对象 x 时，会自动调用 <code>iter(x)</code>。</p><p>内置的 iter 函数有以下作用。</p><ol><li>检查对象是否实现了 <code>__iter__</code> 方法，如果实现了就调用它，获取一个迭代器。</li><li>如果没有实现 <code>__iter__</code> 方法，但是实现了 <code>__getitem__</code> 方法， Python 会创建一个迭代器，尝试按顺序（从索引 0 开始）获取元素。</li><li>如果尝试失败，Python 抛出 <code>TypeError</code> 异常，通常会提示“C object is not iterable”（C 对象不可迭代），其中 C 是目标对象所属的类。</li></ol><p>任何 Python 序列都可迭代的原因是，它们都实现了 <code>__getitem__</code> 方法。其实，标准的序列也都实现了 <code>__iter__</code> 方法，因此你也应该这么做。之所以对 <code>__getitem__</code> 方法做特殊处理，是为了向后兼容，而未来可能不会再这么做。</p><p><strong>从 Python 3.4 开始，检查对象 x 能否迭代，最准确的方法是：调用 <code>iter(x)</code> 函数，如果不可迭代，再处理 <code>TypeError</code> 异常。</strong></p><h2 id="14-2-可迭代的对象与迭代器的对比"><a href="#14-2-可迭代的对象与迭代器的对比" class="headerlink" title="14.2　可迭代的对象与迭代器的对比"></a>14.2　可迭代的对象与迭代器的对比</h2><p>可迭代对象：</p><ul><li>实现了能返回迭代器的 <code>__iter__</code> 方法的对象</li><li>实现了 <code>__getitem__</code> 方法，且参数是从 0 开始的索引的对象</li></ul><p>Python 会从可迭代对象中获取<strong>迭代器</strong>来进行迭代操作。</p><p>例如下面的例子，背后是有迭代器的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'ABC'</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">    print(char)</span><br></pre></td></tr></table></figure><p>如果没有 <code>for</code> 语句的话，则需要使用 <code>while</code> 来模拟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'ABC'</span></span><br><span class="line">it = iter(s)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(next(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">del</span> it</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>标准的迭代器接口有两个方法：</p><ul><li><code>__next__</code>：返回下一个可用的元素</li><li><code>__iter__</code>：返回 <code>self</code>，以便在可使用迭代对象的地方使用迭代器</li></ul><p>这个接口在 <code>collections.abc.Iterator</code> 抽象基类中制定，该接口使用了 <code>__subclasshook__</code> 来判断某个类是否是其子类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span><span class="params">(Iterable)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (any(<span class="string">"__next__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__)) <span class="keyword">and</span></span><br><span class="line">        (any(<span class="string">"__iter__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure><blockquote><p><code>__subclasshook__(subclass)</code>必须定义为类方法。该方法检查 subclass 是否是该抽象基类的子类。该方法必须返回 <code>True</code>, <code>False</code> 或是 <code>NotImplemented</code>。如果返回 <code>True</code>，subclass 就会被认为是这个抽象基类的子类。如果返回 <code>False</code>，无论正常情况是否应该认为是其子类，统一视为不是。如果返回 <code>NotImplemented</code>，子类检查会按照正常机制继续执行。</p></blockquote><h2 id="14-3-Sentence-类第2版：典型的迭代器"><a href="#14-3-Sentence-类第2版：典型的迭代器" class="headerlink" title="14.3 Sentence 类第2版：典型的迭代器"></a>14.3 Sentence 类第2版：典型的迭代器</h2><p>在这一个版本中，我们根据《设计模式：可复用面向对象软件的基础》一书中给出的模型来实现典型的迭代器设计模式，但这并不符合 Python 的习惯做法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> SentenceIterator(self.words)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentenceIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        self.words = words</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            word = self.words[self.index]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><p>这一版的工作量很大（对于懒惰的 Python 程序员来说的确如此）。</p><h3 id="把-Sentence-变成迭代器：BAD-IDEA-！"><a href="#把-Sentence-变成迭代器：BAD-IDEA-！" class="headerlink" title="把 Sentence 变成迭代器：BAD IDEA ！"></a>把 Sentence 变成迭代器：BAD IDEA ！</h3><p>构建可迭代的对象和迭代器时经常会出现错误，原因是混淆了二者。要知道，可迭代对象有个 <code>__iter__</code> 方法，每次都实例化一个新的迭代器；而迭代器要实现 <code>__next__</code> 方法，返回单个元素，此外还要实现 <code>__iter__</code> 方法，返回迭代器本身。</p><p><strong>切忌将 Sentence 类实现为迭代器！因为可迭代对象必须能够返回多个独立的迭代器，而每个迭代器要能维护自身内部的状态！</strong></p><h2 id="14-4-Sentence-类第3版：生成器函数"><a href="#14-4-Sentence-类第3版：生成器函数" class="headerlink" title="14.4 Sentence 类第3版：生成器函数"></a>14.4 Sentence 类第3版：生成器函数</h2><p>实现相同的功能，Python 习惯的方式是用生成器函数代替 SentenceIterator 类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> self.words:</span><br><span class="line">            <span class="keyword">yield</span> word</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>只要 Python 函数的定义体中有 <code>yield</code> 关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。</p><p>下面一个特别简单的函数说明生成器的行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">3</span>]: <span class="function"><span class="keyword">def</span> <span class="title">gen123</span><span class="params">()</span>:</span></span><br><span class="line">   ...:     <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">   ...:     <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">   ...:     <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: gen123</span><br><span class="line">Out[<span class="number">4</span>]: &lt;function __main__.gen123()&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: gen123()</span><br><span class="line">Out[<span class="number">8</span>]: &lt;generator object gen123 at <span class="number">0x10287ff10</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> gen123():</span><br><span class="line">    ...:     print(i)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: g = gen123()</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: next(g)</span><br><span class="line">Out[<span class="number">12</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: next(g)</span><br><span class="line">Out[<span class="number">13</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: next(g)</span><br><span class="line">Out[<span class="number">14</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: next(g)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">StopIteration                             Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-15</span>-e734f8aca5ac&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 next(g)</span><br><span class="line"></span><br><span class="line">StopIteration:</span><br></pre></td></tr></table></figure><p>生成器函数会创建一个生成器对象，包装生成器函数的定义体。把生成器传给 next 函数时，生成器函数会向前，执行函数定义体中的下一个 <code>yield</code> 语句，返回产出的值，并在函数定义体的当前位置暂停。</p><p>这一版 Sentence 类比前一版简短多了，但是还不够懒惰。如今，人们认为惰性是好的特质，至少在编程语言和 API 中是如此。惰性实现是指尽可能延后生成值。这样做能节省内存，而且或许还可以避免做无用的处理。</p><h2 id="14-5-Sentence-类第4版：惰性实现"><a href="#14-5-Sentence-类第4版：惰性实现" class="headerlink" title="14.5 Sentence 类第4版：惰性实现"></a>14.5 Sentence 类第4版：惰性实现</h2><p>目前实现的几版 Sentence 类都不具有惰性，因为 <code>__init__</code> 方法在一开始就构建好了文本中的单词列表，然后将其绑定到 <code>self.words</code> 属性上。</p><p>为了解决这个问题，我们可以使用 <code>re.finditer</code> 函数，<code>re.finditer</code> 函数是 <code>re.findall</code> 函数的惰性版本，返回的不是列表，而是一个生成器，按需生成 <code>re.MatchObject</code> 实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text):</span><br><span class="line">          <span class="keyword">yield</span> match.group()</span><br></pre></td></tr></table></figure><h2 id="14-6-Sentence-类第5版：生成器表达式"><a href="#14-6-Sentence-类第5版：生成器表达式" class="headerlink" title="14.6 Sentence 类第5版：生成器表达式"></a>14.6 Sentence 类第5版：生成器表达式</h2><p>生成器表达式可以理解为列表推导的惰性版本：不会迫切地构建列表，而是返回一个生成器，按需惰性生成元素。也就是说，如果列表推导是制造列表的工厂，那么生成器表达式就是制造生成器的工厂。</p><p>下面是列表推导和生成器表达式的对比：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="function"><span class="keyword">def</span> <span class="title">gen_AB</span><span class="params">()</span>:</span></span><br><span class="line">   ...:     print(<span class="string">'start'</span>)</span><br><span class="line">   ...:     <span class="keyword">yield</span> <span class="string">'A'</span></span><br><span class="line">   ...:     print(<span class="string">'continue'</span>)</span><br><span class="line">   ...:     <span class="keyword">yield</span> <span class="string">'B'</span></span><br><span class="line">   ...:     print(<span class="string">'end.'</span>)</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: res1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB()]</span><br><span class="line">start</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">end.</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: res1</span><br><span class="line">Out[<span class="number">4</span>]: [<span class="string">'A'</span>, <span class="string">'B'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: res2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB())</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: res2</span><br><span class="line">Out[<span class="number">6</span>]: &lt;generator object &lt;genexpr&gt; at <span class="number">0x1027dbca8</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> res2:</span><br><span class="line">   ...:     print(i)</span><br><span class="line">   ...:</span><br><span class="line">start</span><br><span class="line">A</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">B</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><p>使用生成器表达式，我们能够进一步减少 Sentence 实现的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (match.group() <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text))</span><br></pre></td></tr></table></figure><p>生成器表达式是语法糖：完全可以替换成生成器函数，不过有时使用生成器表达式更便利。</p><h2 id="14-7-何时使用生成器表达式"><a href="#14-7-何时使用生成器表达式" class="headerlink" title="14.7 何时使用生成器表达式"></a>14.7 何时使用生成器表达式</h2><p>生成器表达式是创建生成器的简洁句法，这样无需先定义函数再调用。不过，生成器函数灵活得多，可以使用多个语句实现复杂的逻辑，也可以作为协程使用。</p><p>选择使用哪种句法很容易判断：如果生成器表达式要分成多行写，推荐定义生成器函数，以便提高可读性。此外，生成器函数有名称，因此可以重用。</p><h2 id="14-9-标准库中的生成器函数"><a href="#14-9-标准库中的生成器函数" class="headerlink" title="14.9 标准库中的生成器函数"></a>14.9 标准库中的生成器函数</h2><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>第一组是用于过滤的生成器函数：从输入的可迭代对象中产出元素的子集，而且不修改元素本身。</p><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>itertools</td><td>compress(it, selector_it)</td><td>并行处理两个可迭代对象；如果 selector_it 中的元素是真值，产出 it 中对应的元素</td></tr><tr><td>itertools</td><td>dropwhile(predicate, it)</td><td>处理 it，跳过 predicate 的计算结果为真值的元素，然后产出剩下的各个元素（不再进一步检查）</td></tr><tr><td>（内置）</td><td>filter</td><td>把 it 中的各个元素传给 predicate，如果 返回真值，那么产出对应的元素，如果 predicate 是 None，那么只产出真值元素</td></tr><tr><td>itertools</td><td>filterfalse(predicate, it)</td><td>与 filter 函数的作用类似，不过 predicate 的逻辑是相反的：predicate 返回假值时产出对应的元素</td></tr><tr><td>itertools</td><td>islice(it, stop) 或 islice(it, start, stop, step=1)</td><td>产出 it 的切片，作用类似于 <code>s[:stop]</code> 或 <code>s[start:stop:step]</code>，不过 it 可以是任何可迭代的对象，而且这个函数实现的是惰性操作</td></tr><tr><td>itertools</td><td>takewhile(predicate, it)</td><td>predicate 返回真值时产出对应的元素，然后立即停止，不再继续检查</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="function"><span class="keyword">def</span> <span class="title">vowel</span><span class="params">(c)</span>:</span></span><br><span class="line">   ...:     <span class="keyword">return</span> c.lower() <span class="keyword">in</span> <span class="string">'aeiou'</span></span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: list(filter(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">Out[<span class="number">3</span>]: [<span class="string">'A'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: list(itertools.filterfalse(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">Out[<span class="number">4</span>]: [<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'v'</span>, <span class="string">'r'</span>, <span class="string">'k'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: list(itertools.dropwhile(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">Out[<span class="number">5</span>]: [<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'v'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'k'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: list(itertools.takewhile(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">Out[<span class="number">6</span>]: [<span class="string">'A'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: list(itertools.compress(<span class="string">'Aardvark'</span>, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]))</span><br><span class="line">Out[<span class="number">7</span>]: [<span class="string">'A'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: list(itertools.islice(<span class="string">'Aardvark'</span>, <span class="number">4</span>))</span><br><span class="line">Out[<span class="number">8</span>]: [<span class="string">'A'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: list(itertools.islice(<span class="string">'Aardvark'</span>, <span class="number">4</span>, <span class="number">7</span>))</span><br><span class="line">Out[<span class="number">9</span>]: [<span class="string">'v'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: list(itertools.islice(<span class="string">'Aardvark'</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">10</span>]: [<span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br></pre></td></tr></table></figure><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>下一组是用于映射的生成器函数：在输入的单个可迭代对象（map 和 starmap 函数处理多个可迭代的对象）中的各个元素上做计算，然后返回结果。</p><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>itertools</td><td>accumulate(it, [func])</td><td>产出累积的总和；如果提供了 func，那么把前两个元素传给它，然后把计算结果和下一个元素传给它，以此类推，最后产出结果</td></tr><tr><td>（内置）</td><td>enumerate(iterable, start=0)</td><td>产出由两个元素组成的元组，结构是 (index, item) ，其中 index 从 start 开始计数，item 则从 iterable 中获取</td></tr><tr><td>内置</td><td>map(func, it1, [it2, …, itN])</td><td>把 it 中的各个元素传给func，产出结果；如果传入 N 个可迭代的对象，那么 func 必须能接受 N 个参数，而且要并行处理各个可迭代的对象</td></tr><tr><td>itertools</td><td>starmap(func, it)</td><td>把 it 中的各个元素传给 func，产出结果；输入的可迭代对象应该产出可迭代的元素 iit，然后以 <code>func(*iit)</code> 这种形式调用 func</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">11</span>]: sample = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: <span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: list(itertools.accumulate(sample))</span><br><span class="line">Out[<span class="number">13</span>]: [<span class="number">5</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">32</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">44</span>, <span class="number">45</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: list(itertools.accumulate(sample, min))</span><br><span class="line">Out[<span class="number">14</span>]: [<span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: list(itertools.accumulate(sample, max))</span><br><span class="line">Out[<span class="number">15</span>]: [<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: <span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: list(itertools.accumulate(sample, operator.mul))</span><br><span class="line">Out[<span class="number">17</span>]: [<span class="number">5</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">320</span>, <span class="number">2240</span>, <span class="number">13440</span>, <span class="number">40320</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: list(itertools.starmap(operator.mul, enumerate(<span class="string">'albatroz'</span>, <span class="number">1</span>)))</span><br><span class="line">Out[<span class="number">18</span>]: [<span class="string">'a'</span>, <span class="string">'ll'</span>, <span class="string">'bbb'</span>, <span class="string">'aaaa'</span>, <span class="string">'ttttt'</span>, <span class="string">'rrrrrr'</span>, <span class="string">'ooooooo'</span>, <span class="string">'zzzzzzzz'</span>]</span><br></pre></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>接下来这一组是用于合并的生成器函数，这些函数都从输入的多个可迭代对象中产出元素。</p><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>itertools</td><td>chain(it1, …, itN)</td><td>先产出 it1 中的所有元素，然后产出 it2 中的所有元素，以此类推，无缝连接在一起</td></tr><tr><td>itertools</td><td>chain.from_iterable(it)</td><td>产出 it 生成的各个可迭代对象中的元素，一个接一个，无缝连接在一起；it 应该产出可迭代的元素，例如可迭代的对象列表</td></tr><tr><td>itertools</td><td>product(it1, …, itN, repeat=1)</td><td>计算笛卡儿积：从输入的各个可迭代对象中获取元素，合并成由 N 个元素组成的元组，与嵌套的 for 循环效果一样；repeat 指明重复处理多少次输入的可迭代对象</td></tr><tr><td>（内置）</td><td>zip(it1, …, itN)</td><td>并行从输入的各个可迭代对象中获取元素，产出由 N 个元素组成的元组，只要有一个可迭代的对象到头了，就默默地停止</td></tr><tr><td>itertools</td><td>zip_longest(it1, …, itN, fillvalue=None)</td><td>并行从输入的各个可迭代对象中获取元素，产出由 N 个元素组成的元组，等到最长的可迭代对象到头后才停止，空缺的值使用 fillvalue 填充</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: list(itertools.chain(<span class="string">'ABC'</span>, range(<span class="number">2</span>)))</span><br><span class="line">Out[<span class="number">2</span>]: [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: list(itertools.chain(enumerate(<span class="string">'ABC'</span>)))</span><br><span class="line">Out[<span class="number">3</span>]: [(<span class="number">0</span>, <span class="string">'A'</span>), (<span class="number">1</span>, <span class="string">'B'</span>), (<span class="number">2</span>, <span class="string">'C'</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: list(itertools.chain.from_iterable(enumerate(<span class="string">'ABC'</span>)))</span><br><span class="line">Out[<span class="number">4</span>]: [<span class="number">0</span>, <span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">2</span>, <span class="string">'C'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: list(zip(<span class="string">'ABC'</span>, range(<span class="number">5</span>)))</span><br><span class="line">Out[<span class="number">5</span>]: [(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: list(zip(<span class="string">'ABC'</span>, range(<span class="number">5</span>), [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]))</span><br><span class="line">Out[<span class="number">6</span>]: [(<span class="string">'A'</span>, <span class="number">0</span>, <span class="number">10</span>), (<span class="string">'B'</span>, <span class="number">1</span>, <span class="number">20</span>), (<span class="string">'C'</span>, <span class="number">2</span>, <span class="number">30</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: list(itertools.zip_longest(<span class="string">'ABC'</span>, range(<span class="number">5</span>)))</span><br><span class="line">Out[<span class="number">8</span>]: [(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">2</span>), (<span class="literal">None</span>, <span class="number">3</span>), (<span class="literal">None</span>, <span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: list(itertools.zip_longest(<span class="string">'ABC'</span>, range(<span class="number">5</span>), fillvalue=<span class="string">'?'</span>))</span><br><span class="line">Out[<span class="number">9</span>]: [(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">2</span>), (<span class="string">'?'</span>, <span class="number">3</span>), (<span class="string">'?'</span>, <span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: list(itertools.product(<span class="string">'ABC'</span>, range(<span class="number">2</span>)))</span><br><span class="line">Out[<span class="number">10</span>]: [(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'A'</span>, <span class="number">1</span>), (<span class="string">'B'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">0</span>), (<span class="string">'C'</span>, <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: list(itertools.product(<span class="string">'ABC'</span>))</span><br><span class="line">Out[<span class="number">11</span>]: [(<span class="string">'A'</span>,), (<span class="string">'B'</span>,), (<span class="string">'C'</span>,)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: list(itertools.product(<span class="string">'ABC'</span>, repeat=<span class="number">2</span>))</span><br><span class="line">Out[<span class="number">12</span>]:</span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'A'</span>),</span><br><span class="line"> (<span class="string">'A'</span>, <span class="string">'B'</span>),</span><br><span class="line"> (<span class="string">'A'</span>, <span class="string">'C'</span>),</span><br><span class="line"> (<span class="string">'B'</span>, <span class="string">'A'</span>),</span><br><span class="line"> (<span class="string">'B'</span>, <span class="string">'B'</span>),</span><br><span class="line"> (<span class="string">'B'</span>, <span class="string">'C'</span>),</span><br><span class="line"> (<span class="string">'C'</span>, <span class="string">'A'</span>),</span><br><span class="line"> (<span class="string">'C'</span>, <span class="string">'B'</span>),</span><br><span class="line"> (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: list(itertools.product(<span class="string">'ABC'</span>, range(<span class="number">2</span>), repeat=<span class="number">2</span>))</span><br><span class="line">Out[<span class="number">13</span>]:</span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'C'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'C'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'C'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'C'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'C'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'C'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'C'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'C'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'C'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'C'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'C'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'C'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'C'</span>, <span class="number">0</span>, <span class="string">'C'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'C'</span>, <span class="number">0</span>, <span class="string">'C'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'C'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'C'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'C'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'C'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'C'</span>, <span class="number">1</span>, <span class="string">'C'</span>, <span class="number">0</span>),</span><br><span class="line"> (<span class="string">'C'</span>, <span class="number">1</span>, <span class="string">'C'</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>有些生成器函数会从一个元素中产出多个值，扩展输入的可迭代对象。</p><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>itertools</td><td>combinations(it, out_len)</td><td>把 it 产出的 out_len 个元素组合在一起，然后产出</td></tr><tr><td>itertools</td><td>combinations_with_replacement(it, out_len)</td><td>把 it 产出的 out_len 个元素组合在一起，然后产出，包含相同元素的组合</td></tr><tr><td>itertools</td><td>count(start=0, step=1)</td><td>从 start 开始不断产出数字，按 step 指定的步幅增加</td></tr><tr><td>itertools</td><td>cycle(it)</td><td>从 it 中产出各个元素，存储各个元素的副本，然后按顺序重复不断地产出各个元素</td></tr><tr><td>itertools</td><td>permutations(it, out_len=None)</td><td>把 out_len 个 it 产出的元素排列在一起，然后产出这些排列；out_len 的默认值等于 <code>len(list(it))</code></td></tr><tr><td>itertools</td><td>repeat(item, [times])</td><td>重复不断地产出指定的元素，除非提供 times，指定次数</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: list(itertools.combinations(<span class="string">'ABC'</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">2</span>]: [(<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: list(itertools.combinations_with_replacement(<span class="string">'ABC'</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">3</span>]: [(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: list(itertools.permutations(<span class="string">'ABC'</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">4</span>]: [(<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'A'</span>), (<span class="string">'C'</span>, <span class="string">'B'</span>)]</span><br></pre></td></tr></table></figure><h3 id="重排列"><a href="#重排列" class="headerlink" title="重排列"></a>重排列</h3><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>itertools</td><td>groupby(it, key=None)</td><td>产出由两个元素组成的元素，形式为 (key, group) ，其中 key 是分组标准，group 是生成器，用于产出分组里的元素</td></tr><tr><td>（内置）</td><td>reversed(seq)</td><td>从后向前，倒序产出 seq 中的元素；<strong>seq 必须是序 列，或者是实现了 <code>__reversed__</code> 特殊方法的对象</strong></td></tr><tr><td>itertools</td><td>tee(it, n=2)</td><td>产出一个由 n 个生成器组成的元组，每个生成器 用于单独产出输入的可迭代对象中的元素</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: list(itertools.combinations(<span class="string">'ABC'</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">2</span>]: [(<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: list(itertools.combinations_with_replacement(<span class="string">'ABC'</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">3</span>]: [(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: list(itertools.permutations(<span class="string">'ABC'</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">4</span>]: [(<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'A'</span>), (<span class="string">'C'</span>, <span class="string">'B'</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: <span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: list(itertools.groupby(<span class="string">'LLLLAAGGG'</span>))</span><br><span class="line">Out[<span class="number">6</span>]:</span><br><span class="line">[(<span class="string">'L'</span>, &lt;itertools._grouper at <span class="number">0x10eaaf7b8</span>&gt;),</span><br><span class="line"> (<span class="string">'A'</span>, &lt;itertools._grouper at <span class="number">0x10eaaf7f0</span>&gt;),</span><br><span class="line"> (<span class="string">'G'</span>, &lt;itertools._grouper at <span class="number">0x10eaaf8d0</span>&gt;)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: <span class="keyword">for</span> char, group <span class="keyword">in</span> itertools.groupby(<span class="string">'LLLLAAGGG'</span>):</span><br><span class="line">   ...:     print(char, <span class="string">'-&gt;'</span>, list(group))</span><br><span class="line">   ...:</span><br><span class="line">L -&gt; ['L', 'L', 'L', 'L']</span><br><span class="line">A -&gt; ['A', 'A']</span><br><span class="line">G -&gt; ['G', 'G', 'G']</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: animals = [<span class="string">'duck'</span>, <span class="string">'eagle'</span>, <span class="string">'rat'</span>, <span class="string">'giraffe'</span>, <span class="string">'bear'</span>, <span class="string">'bat'</span>, <span class="string">'dolphin'</span>, <span class="string">'shark'</span>, <span class="string">'lion'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: animals.sort(key=len)</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: animals</span><br><span class="line">Out[<span class="number">10</span>]: [<span class="string">'rat'</span>, <span class="string">'bat'</span>, <span class="string">'duck'</span>, <span class="string">'bear'</span>, <span class="string">'lion'</span>, <span class="string">'eagle'</span>, <span class="string">'shark'</span>, <span class="string">'giraffe'</span>, <span class="string">'dolphin'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: <span class="keyword">for</span> length, group <span class="keyword">in</span> itertools.groupby(animals, len):</span><br><span class="line">    ...:     print(length, <span class="string">'-&gt;'</span>, list(group))</span><br><span class="line">    ...:</span><br><span class="line">3 -&gt; ['rat', 'bat']</span><br><span class="line">4 -&gt; ['duck', 'bear', 'lion']</span><br><span class="line">5 -&gt; ['eagle', 'shark']</span><br><span class="line">7 -&gt; ['giraffe', 'dolphin']</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: <span class="keyword">for</span> length, group <span class="keyword">in</span> itertools.groupby(reversed(animals), len):</span><br><span class="line">    ...:     print(length, <span class="string">'-&gt;'</span>, list(group))</span><br><span class="line">    ...:</span><br><span class="line">7 -&gt; ['dolphin', 'giraffe']</span><br><span class="line">5 -&gt; ['shark', 'eagle']</span><br><span class="line">4 -&gt; ['lion', 'bear', 'duck']</span><br><span class="line">3 -&gt; ['bat', 'rat']</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: list(zip(*itertools.tee(<span class="string">'ABC'</span>)))</span><br><span class="line">Out[<span class="number">15</span>]: [(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: list(zip(*itertools.tee(<span class="string">'ABC'</span>, <span class="number">3</span>)))</span><br><span class="line">Out[<span class="number">16</span>]: [(<span class="string">'A'</span>, <span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br></pre></td></tr></table></figure><h2 id="14-10-Python-3-3中新出现的句法：yield-from"><a href="#14-10-Python-3-3中新出现的句法：yield-from" class="headerlink" title="14.10　Python 3.3中新出现的句法：yield from"></a>14.10　Python 3.3中新出现的句法：yield from</h2><p>如果生成器函数需要产出另一个生成器生成的值，传统的解决方法是使用嵌套的 for 循环，例如下面自己实现的 chain 的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line">      <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure><p>在 PEP380 中引入了一个新的句法：<code>yield from</code>，它能够替代我们内层的 for 循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> it</span><br></pre></td></tr></table></figure><p><code>yield from</code> 不仅仅是语法糖，其还会创建通道，把内层生成器直接与外层生成器的客户端联系起来。把生成器当成协程使用时，这个通道特别重要，不仅能为客户端代码生成值，还能使用客户端代码提供的值。</p><h2 id="14-12-深入分析-iter-函数"><a href="#14-12-深入分析-iter-函数" class="headerlink" title="14.12　深入分析 iter 函数"></a>14.12　深入分析 iter 函数</h2><p>如前所述，在 Python 中迭代对象 x 时会调用 <code>iter(x)</code>。</p><p>可是，iter 函数还有一个鲜为人知的用法：传入两个参数，使用常规的函数或任何可调用的对象创建迭代器。这样使用时，第一个参数必须是可调用的对象，用于不断调用（没有参数），产出各个值；第二个值是哨符，这是个标记值，当可调用的对象返回这个值时，触发迭代器抛出 StopIteration 异常，而不产出哨符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">21</span>]: <span class="function"><span class="keyword">def</span> <span class="title">d6</span><span class="params">()</span>:</span></span><br><span class="line">    ...:     <span class="keyword">return</span> randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]:</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: <span class="function"><span class="keyword">def</span> <span class="title">d6</span><span class="params">()</span>:</span></span><br><span class="line">    ...:     <span class="keyword">return</span> randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: d6_iter = iter(d6, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: d6_iter</span><br><span class="line">Out[<span class="number">24</span>]: &lt;callable_iterator at <span class="number">0x10ee55b70</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: <span class="keyword">for</span> roll <span class="keyword">in</span> iter(d6, <span class="number">1</span>):</span><br><span class="line">    ...:     print(roll)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>内置函数 iter 的文档中有个实用的例子。这段代码逐行读取文件，直到遇到空行或者到达文件末尾为止：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'mydata.txt'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> iter(fp.readline, <span class="string">'\n'</span>):</span><br><span class="line">    process_line(line)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;14-1-Sentence-类第1版：单词序列&quot;&gt;&lt;a href=&quot;#14-1-Sentence-类第1版：单词序列&quot; class=&quot;headerlink&quot; title=&quot;14.1　Sentence 类第1版：单词序列&quot;&gt;&lt;/a&gt;14.1　Sentence 类第1
      
    
    </summary>
    
      <category term="Fluent Python" scheme="https://homholueng.github.io/categories/Fluent-Python/"/>
    
    
      <category term="Python" scheme="https://homholueng.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>思维导图与高效学习</title>
    <link href="https://homholueng.github.io/2019/08/17/effective-way-mind-map/"/>
    <id>https://homholueng.github.io/2019/08/17/effective-way-mind-map/</id>
    <published>2019-08-16T17:20:13.000Z</published>
    <updated>2019-08-20T13:36:55.996Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>相信我们在生活中会经常使用思维导图来进行规划，总结，事项整理等，思维导图由 Tony Buzan 创建，是一种风靡全球的工具。可用于生活，和工作中；他能够辅助我们思考，发散，并将思维和逻辑具象化和形式化；本文是《思维导图与高效学习术》课程的总结，所以，本文也会尝试使用思维导图来进行课程知识的总结和归纳。</p></blockquote><h2 id="思维导图的特点"><a href="#思维导图的特点" class="headerlink" title="思维导图的特点"></a>思维导图的特点</h2><ul><li>C：从一张纸的<strong>中心开始</strong>思考</li><li>R：<strong>放射状</strong>往外有层次<em>逻辑扩散</em>（先放后收）</li><li>O：采用<strong>关键词</strong>重点思考技术</li><li>C：运用<strong>图像</strong>与<strong>颜色</strong>让思考活络容易记忆</li></ul><h3 id="思维导图的形式"><a href="#思维导图的形式" class="headerlink" title="思维导图的形式"></a>思维导图的形式</h3><ol><li>全图思维导图：由<em>图像</em>和<em>线条</em>组成，适合用在<strong>吸引眼球</strong>以及<strong>内容需要被记住</strong>的场景；但是需要注意，一般需要有人解说，并且需要控制内容的数量。</li><li>全文思维导图：由<em>文字</em>和<em>线条</em>组成，适合用在<strong>信息量多</strong>，重点需要被精准传递的场景；职场上用的一般比较多。</li><li>图文思维导图：有<em>图像</em>，<em>文字</em>与<em>线条</em>组成，既能<strong>透过文字传达内容</strong>，又能运用<strong>图像表示出重点与亮点</strong>；是目前全球最多人使用的形式。</li></ol><h3 id="思维导图的结构"><a href="#思维导图的结构" class="headerlink" title="思维导图的结构"></a>思维导图的结构</h3><ul><li>中心主题：中心主题（Central Image），位于导图的中央，代表导图的题目；主题能够帮助我们防止思考跑题。</li><li>主干：从中心主题延伸出来的第一层线条，代表大项，是大方向的思考，称之为主干（Main Branch）；辅助大脑快速定位到思考的大方向。</li><li>支干：在主干后面所有细细的线条是第三个结构：支干（Sub-Branch），支干上方的信息是经过整理的重要细节内容。</li></ul><h3 id="思维导图的要素"><a href="#思维导图的要素" class="headerlink" title="思维导图的要素"></a>思维导图的要素</h3><ul><li>文字：传递信息，表达重点；一般使用的都是关键字。</li><li>线条：穿针引线，组织架构；呈现思维的脉络。</li><li>图像：强调重点，带动情感；吸引人的注意力。</li></ul><h2 id="思维导图的应用"><a href="#思维导图的应用" class="headerlink" title="思维导图的应用"></a>思维导图的应用</h2><p>思维导图能够用于很多场景，但我们可以将其划分为两大类别：</p><ul><li>输入（Taking）：从外界撷取信息到大脑中。<ul><li>笔记</li><li>会议</li><li>谈话摘录</li><li>整理想法</li></ul></li><li>输出（Making）：组织运用自己大脑内的想法及数据。<ul><li>工作规划</li><li>汇报构思</li><li>头脑风暴</li><li>问题分析</li></ul></li></ul><h2 id="思维导图思考技术"><a href="#思维导图思考技术" class="headerlink" title="思维导图思考技术"></a>思维导图思考技术</h2><p>思维导图在使用时有两个比较关键的思考技术：<strong>Key Word</strong> 及 <strong>BOIs</strong>，能够帮助我们尽可能的发挥思维导图的价值。</p><h3 id="Key-Word-技术"><a href="#Key-Word-技术" class="headerlink" title="Key Word 技术"></a>Key Word 技术</h3><p>关键词可以勾起我们大脑想到关键词所代表的意义、相关重要内容、当时学习时的情景等。关键词通常是<strong>名词</strong>或<strong>动词</strong>；以一个字、词或凝聚概念为主。</p><p>通过拆分关键词技术，在思维导图中我们能够创建更多的活口，因为每一个关键词都是思考的<strong>起点</strong>与<strong>刺激点</strong>。也就是说，关键词技术的价值是在思考时，帮助我们快速提升想法的数量，扩增想法的广度。</p><p>而在输入和输出的应用上，关键词拆解的程度有所不同，在输出时，想法的数量会影响最终收敛结果的品质，所以请严格遵守一个关键词，也就是<strong>一词一线元组</strong>；再输入的应用上，可以视情况而定给出弹性，对于没有保留活口的整理需求，可以适度的结合关键词，也就是弹性使用一线二词。</p><p>下面给出一个拆解关键词的实例，假设我们需要给公司的老客户进行一些回馈，而其中一项是赠送生日礼物，那么通过关键字拆解技术，我们能够拆解成<strong>礼物</strong>和<strong>生日</strong>两个关键字，这使得我们留出了一个思考的活口和空间，即在礼物和生日之间的一个思考空间，通过这个思考空间，我们能够发散出生日礼物，情人节礼物，春节礼物等更多的细项目：</p><img src="/2019/08/17/effective-way-mind-map/key_word.png" title="[KeyWord]"><h3 id="BOIs-系统思考"><a href="#BOIs-系统思考" class="headerlink" title="BOIs 系统思考"></a>BOIs 系统思考</h3><p>BOIs 是 Basic Ordering Ideas 的缩写，透过加入更细的分类阶层，让想法更全更周延，其最大的价值在找出遗漏的思维，从跳脱信息接收与梳理的层次，更进一步主动思考其他的可能性，让整个思考过程更完整。</p><p>BOIs 的快速启动步骤如下：</p><ol><li>想法出现之后，先找大类，即我们的主干，这被称之为主干技术。</li><li>思考大类与想法之间是否有更细的功能性位阶。</li></ol><p>锻炼 BOIs 技术的方法是：<strong>先画一条空白线</strong>。因为大脑追求完成的倾向，会让我们想要填满它，进而刺激我们去思考。</p><p>这个技术能够帮助我们提升思维的完整性和缜密度，但是要注意，在运用时不要将小事搞得过于复杂，我们应该积极锻炼我们的思考能力，但是在应用时要视场景而定，避免用力过猛。</p><p>下面给出一个 BOIs 的实例，在我们上一节使用 Key Word 技术拆分的基础上，我们进行进一步的思考。首先，我们在礼物（大类）与生日（想法）之间画出一条白线，然后填满它，这就是我们的第一个功能性位阶段，最后，我们会通过这条白线的刺激，发散出其他更多的位阶（节日，对象，种类，产品等）：</p><img src="/2019/08/17/effective-way-mind-map/bois.png" title="[BOIs]"><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>一般我们会按照以下步骤来绘制思维导图：</p><ol><li>定中心主题</li><li>内容整理分类</li><li>重点加图像</li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="思维导图整理"><a href="#思维导图整理" class="headerlink" title="思维导图整理"></a>思维导图整理</h3><p>思维导图笔记4步骤：</p><ol><li>快速浏览，区分大类</li><li>细读内容，圈关键词</li><li>组织架构，画思维导图</li><li>检查，说图（根据导图向自己或别人讲述笔记的内容）</li></ol><h2 id="其他要点"><a href="#其他要点" class="headerlink" title="其他要点"></a>其他要点</h2><ul><li>根据思维导图面向的对象不同，我们绘制思维导图的风格可能也不一样；例如在面向自己的情况下（笔记，总结），我们可能会以我们自己的思维方式和逻辑来进行绘制，且绘制风格和用词可能会更加偏向自己；而在面向他人的情况下，我们可能需要考虑图的形式（图文，全图，全文），用词和用语，便于他人快速理解。</li><li>在大量的信息面前，思维导图能够帮助我们将信息进行压缩，并提升对信息的价值。</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>下面是通过使用思维导图及相关关键技术对课程的内容进行的归纳和总结：</p><img src="/2019/08/17/effective-way-mind-map/practice.png" title="[实践]">]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;相信我们在生活中会经常使用思维导图来进行规划，总结，事项整理等，思维导图由 Tony Buzan 创建，是一种风靡全球的工具。可用于生活，和工作中；他能够辅助我们思考，发散，并将思维和逻辑具象化和形式化；本文是《思维导图与高效学习术》课程的总结，所
      
    
    </summary>
    
      <category term="Effective Way" scheme="https://homholueng.github.io/categories/Effective-Way/"/>
    
    
      <category term="Effective" scheme="https://homholueng.github.io/tags/Effective/"/>
    
      <category term="Mind Map" scheme="https://homholueng.github.io/tags/Mind-Map/"/>
    
  </entry>
  
  <entry>
    <title>Redis 使用技巧 - Pipelining</title>
    <link href="https://homholueng.github.io/2019/08/11/redis-skill-pipelining/"/>
    <id>https://homholueng.github.io/2019/08/11/redis-skill-pipelining/</id>
    <published>2019-08-11T12:25:35.000Z</published>
    <updated>2019-08-20T13:36:55.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="请求-相应以及-RTT"><a href="#请求-相应以及-RTT" class="headerlink" title="请求/相应以及 RTT"></a>请求/相应以及 RTT</h2><p>Redis 是基于 CS 模型的 TCP 服务器，所以我们每次操作都会遵循如下步骤完成：</p><ul><li>客户端将查询请求发送给服务器，服务器中套接字中读取客户端的请求，客户端会等待服务器的相应，而这个过程通常是阻塞的。</li><li>服务器处理完成后，将响应返回给客户端。</li></ul><p>假设客户端需要向服务器发送四条请求，那么请求和响应顺序应该是这样的：</p><ul><li>Client: INCR X</li><li>Server: 1</li><li>Client: INCR X</li><li>Server: 2</li><li>Client: INCR X</li><li>Server: 3</li><li>Client: INCR X</li><li>Server: 4</li></ul><p>从客户端发起请求的那一刻开始计算，直到客户端收到来自服务器的响应，这中间消耗的时间我们称其为 RTT（Round Trip Time）。当客户端需要在一行（例如往同一个列表中添加多个元素，或是操作同一个数据库中的多个 key 值）上进行多次操作时，RTT 会对性能造成不小的影响。假设我们拥有一台性能强大的服务器，这台服务器能够在一秒内处理 100K 个请求，那么在 RTT 为 250 毫秒的情况下，这个性能强大的服务器一秒内也只能处理 4 个请求。</p><h2 id="Redis-Pipelining"><a href="#Redis-Pipelining" class="headerlink" title="Redis Pipelining"></a>Redis Pipelining</h2><p>Redis 提供的 Pipelining 特性允许我们将多个请求一次性发送给服务器，然后再将所有的响应一次性读取回来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> (printf "PING\r\nPING\r\nPING\r\n"; sleep 1) | nc localhost 6379</span><br><span class="line">+PONG</span><br><span class="line">+PONG</span><br><span class="line">+PONG</span><br></pre></td></tr></table></figure><p>以上小节的例子来看，使用的 Pipelining 之后，请求和相应的顺序应该是这样的(<strong>注意，多条命令是合并在一个请求中发送出去的，处理结果也是在一个响应中返回的</strong>)：</p><ul><li>Client: INCR X</li><li>Client: INCR X</li><li>Client: INCR X</li><li>Client: INCR X</li><li>Server: 1</li><li>Server: 2</li><li>Server: 3</li><li>Server: 4</li></ul><p><strong>如果客户端使用了 Pipelining 这个特性，那么服务器就必须将响应的内容加入到队列中，直到所有操作都处理完成后再一次性返回。当然，这个队列是在内存中的，如果你需要使用 Pipelining 来执行大量的操作，最好是将这些操作进行分批 Pipelining，避免服务器在存储响应内容时消耗过多的内存。</strong></p><h2 id="其实不仅仅是-RTT-的问题"><a href="#其实不仅仅是-RTT-的问题" class="headerlink" title="其实不仅仅是 RTT 的问题"></a>其实不仅仅是 RTT 的问题</h2><p>Pipelining 这个特性其实不仅仅是解决了 RTT 开销的问题，还防止了过多 socket I/O 带来的消耗，因为多条操作指令能够在一次 <code>read()</code> 系统调用中读取出来，多条响应内容也能够在一次 <code>write()</code> 系统调用中完成写入。</p><p>从官方文档给出的资料可以看出，随着 Pipelining 指令数量的增长，服务器的 qps 也成近似指数关系的增长，最后稳定在大概十倍的位置：</p><img src="/2019/08/11/redis-skill-pipelining/pipeline_iops.png" title="[pipeline_iops]"><h2 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h2><p>下面是一段使用 Python 代码进行的测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">TIMES = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bench</span><span class="params">(func, desc)</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    func()</span><br><span class="line">    print(<span class="string">'&#123;desc&#125; &#123;cost&#125; milliseconds'</span>.format(desc=desc, cost=time.time() - start)) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">without_pipeling</span><span class="params">()</span>:</span></span><br><span class="line">    r = redis.Redis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(TIMES):</span><br><span class="line">        r.ping()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">with_pipelining</span><span class="params">()</span>:</span></span><br><span class="line">    r = redis.Redis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>)</span><br><span class="line">    <span class="keyword">with</span> r.pipeline(transaction=<span class="literal">False</span>) <span class="keyword">as</span> p:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(TIMES):</span><br><span class="line">            p.ping()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bench(without_pipeling, <span class="string">'without_pipeling'</span>)</span><br><span class="line">    bench(with_pipelining, <span class="string">'with_pipelining'</span>)</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">without_pipeling 1.24247217178 milliseconds</span><br><span class="line">with_pipelining 0.0302491188049 milliseconds</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;请求-相应以及-RTT&quot;&gt;&lt;a href=&quot;#请求-相应以及-RTT&quot; class=&quot;headerlink&quot; title=&quot;请求/相应以及 RTT&quot;&gt;&lt;/a&gt;请求/相应以及 RTT&lt;/h2&gt;&lt;p&gt;Redis 是基于 CS 模型的 TCP 服务器，所以我们每次操作都
      
    
    </summary>
    
      <category term="Redis" scheme="https://homholueng.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://homholueng.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 13 - 正确的重载运算符</title>
    <link href="https://homholueng.github.io/2019/08/11/fluent-python-override-op-in-right-way/"/>
    <id>https://homholueng.github.io/2019/08/11/fluent-python-override-op-in-right-way/</id>
    <published>2019-08-10T16:38:36.000Z</published>
    <updated>2019-08-20T13:36:55.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="13-1-运算符重载基础"><a href="#13-1-运算符重载基础" class="headerlink" title="13.1 运算符重载基础"></a>13.1 运算符重载基础</h2><p>Python 在重载运算符上施加了一些限制，做好了灵活性、可用性和安全性的平衡：</p><ul><li>不能重载内置类型的运算符</li><li>不能新建运算符，只能重载现有的</li><li>某些运算符不能重载：<code>is</code>，<code>and</code>，<code>or</code> 和 <code>not</code></li></ul><h2 id="13-2-一元运算符"><a href="#13-2-一元运算符" class="headerlink" title="13.2 一元运算符"></a>13.2 一元运算符</h2><p>支持一元运算符很简单，只需实现相应的特殊方法。这些特殊方法只有一个参数，<code>self</code>。然后，使用符合所在类的逻辑实现。不过，要遵守运算符的一个基本规则：始终返回一个新对象。也就是说，不能修改 <code>self</code>，要创建并返回合适类型的新实例。</p><p>为了支持涉及不同类型的运算，Python 为中缀运算符特殊方法提供了特殊的分派机制。对表达式 <code>a + b</code> 来说，解释器会执行以下几步操作：</p><ol><li>如果 a 有 <code>__add__</code> 方法，而且返回值不是 <code>NotImplemented</code>，调用 <code>a.__add__(b)</code>，然后返回结果。</li><li>如果 a 没有 <code>__add__</code> 方法，或者调用 <code>__add__</code> 方法返回 NotImplemented，检查 b 有没有 <code>__radd__</code> 方法，如果有，而且没有 返回 <code>NotImplemented</code>，调用 <code>b.__radd__(a)</code>，然后返回结果。</li><li>如果 b 没有 <code>__radd__</code> 方法，或者调用 <code>__radd__</code> 方法返回 <code>NotImplemented</code>，抛出 <code>TypeError</code>，并在错误消息中指明操作数类型 不支持。</li></ol><p>在重载运算符时，如果我们在进行处理的过程中抛出了异常，那么我们不应该直接让该异常抛出，因为这样有可能阻断 Python 继续尝试调用其他运算符的流程，所以我们应该将错误捕获，并返回 <code>Notimplemented</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>) </span><br><span class="line">        <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs) </span><br><span class="line">    <span class="keyword">except</span> TypeError:  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure><p>如果操作数的类型不同，我们要检测出不能处理的操作数。可以使用两种方式处理这个问题：一种是鸭子类型，直接尝试执行运算，如果有问题，捕获 <code>TypeError</code> 异常；另一种是显式使用 <code>isinstance</code> 测试，但是不能测试具体类，而要测试例如 <code>numbers.Real</code> 这样的抽象基类。</p><h2 id="13-6-增量赋值运算符"><a href="#13-6-增量赋值运算符" class="headerlink" title="13.6 增量赋值运算符"></a>13.6 增量赋值运算符</h2><p>如果一个类没有实现就地运算符，增量赋值运算符只是语法糖：<code>a += b</code> 的作用与 <code>a = a + b</code> 完全一样。</p><p>然而，如果实现了就地运算符方法，例如 <code>__iadd__</code>，计算 <code>a += b</code> 的结果时会调用就地运算符方法。这种运算符的名称表明，它们会就地修改左操作数，而不会创建新对象作为结果。</p><p><strong>对于不可变类型，一定不能实现就地特殊方法。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;13-1-运算符重载基础&quot;&gt;&lt;a href=&quot;#13-1-运算符重载基础&quot; class=&quot;headerlink&quot; title=&quot;13.1 运算符重载基础&quot;&gt;&lt;/a&gt;13.1 运算符重载基础&lt;/h2&gt;&lt;p&gt;Python 在重载运算符上施加了一些限制，做好了灵活性、可
      
    
    </summary>
    
      <category term="Fluent Python" scheme="https://homholueng.github.io/categories/Fluent-Python/"/>
    
    
      <category term="Python" scheme="https://homholueng.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言圣经 - 6. 方法</title>
    <link href="https://homholueng.github.io/2019/08/07/gopl-method/"/>
    <id>https://homholueng.github.io/2019/08/07/gopl-method/</id>
    <published>2019-08-07T12:02:28.000Z</published>
    <updated>2019-08-07T12:02:28.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-1-方法声明"><a href="#6-1-方法声明" class="headerlink" title="6.1. 方法声明"></a>6.1. 方法声明</h2><p>在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> geometry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traditional function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Distance</span><span class="params">(p, q Point)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// same thing, but as a method of the Point type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Distance</span><span class="params">(q Point)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码里那个附加的参数 <code>p</code>，叫做方法的接收器（receiver），早期的面向对象语言留下的遗产将调用一个方法称为 “向一个对象发送消息”。</p><p>在 Go 语言中，我们并不会像其它语言那样用 this 或者 self 作为接收器；我们可以任意的选择接收器的名字。由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。这里的建议是可以使用其类型的第一个字母，比如这里使用了 Point 的首字母 <code>p</code>。</p><p>而每种类型都有其方法的命名空间，让我们来定义一个 Path 类型，这个 Path 代表一个线段的集合，并且也给这个 Path 定义一个叫 <code>Distance</code> 的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> path []Point</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(path Path)</span> <span class="title">Distance</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> path &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            sum += path[i<span class="number">-1</span>].Distance(path[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在能够给任意类型定义方法这一点上，Go 和很多其它的面向对象的语言不太一样。因此在 Go 语言里，我们为一些简单的数值、字符串、slice、map 来定义一些附加行为很方便。我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型不是指针或者 interface。</p><h2 id="6-2-基于指针对象的方法"><a href="#6-2-基于指针对象的方法" class="headerlink" title="6.2. 基于指针对象的方法"></a>6.2. 基于指针对象的方法</h2><p>当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。对应到我们这里用来更新接收器的对象的方法，当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span> <span class="title">ScaleBy</span><span class="params">(factor <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    p.X *= factor</span><br><span class="line">    p.Y *= factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的名字是 <code>(*Point).ScaleBy</code>。在现实的程序里，一般会约定如果 Point 这个类有一个指针作为接收器的方法，那么所有 Point 的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。</p><p>只有类型（Point）和指向他们的指针 (<code>*Point</code>)，才可能是出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，比如下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> P *<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(P)</span> <span class="title">f</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// compile error: invalid receiver type</span></span><br></pre></td></tr></table></figure><p>想要调用指针类型方法 <code>(*Point).ScaleBy</code>，只要提供一个 Point 类型的指针即可，像下面这样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">r.ScaleBy(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">pptr := &amp;p</span><br><span class="line">pptr.ScaleBy(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">(&amp;p).ScaleBy(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>但是，go 语言本身在这种地方会帮到我们。如果接收器 <code>p</code> 是一个 Point 类型的变量，并且其方法需要一个 Point 指针作为接收器，我们可以用下面这种简短的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.ScaleBy(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>编译器会隐式地帮我们用 <code>&amp;p</code> 去调用 <code>ScaleBy</code> 这个方法。这种简写方法只适用于 “变量”，包括 struct 里的字段比如 <code>p.X</code>，以及 array 和 slice 内的元素比如 <code>perim[0]</code>。我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;.ScaleBy(<span class="number">2</span>) <span class="comment">// compile error: can't take address of Point literal</span></span><br></pre></td></tr></table></figure><p>go 的编译器会隐式为我们 <strong>解引用</strong> 或 <strong>取地址</strong>。、</p><h3 id="6-2-1-Nil-也是一个合法的接收器类型"><a href="#6-2-1-Nil-也是一个合法的接收器类型" class="headerlink" title="6.2.1. Nil 也是一个合法的接收器类型"></a>6.2.1. Nil 也是一个合法的接收器类型</h3><p>就像一些函数允许 nil 指针作为参数一样，方法理论上也可以用 nil 指针作为其接收器，尤其当 nil 对于对象来说是合法的零值时，比如 map 或者 slice。</p><p>当你定义一个允许 nil 作为接收器值的方法的类型时，在类型前面的注释中指出 nil 变量代表的意义是很有必要的。</p><h2 id="6-3-通过嵌入结构体来扩展类型"><a href="#6-3-通过嵌入结构体来扩展类型" class="headerlink" title="6.3. 通过嵌入结构体来扩展类型"></a>6.3. 通过嵌入结构体来扩展类型</h2><p>来看看 ColoredPoint 这个类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"image/color"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Color color.RGBA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过类型为 Point 的匿名成员将 Point 类的方法也引入了 ColoredPoint 中。这种方式可以使我们定义字段特别多的复杂类型，我们可以将字段先按小类型分组，然后定义小类型的方法，之后再把它们组合起来。</p><p>在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中。</p><p>方法只能在命名类型（像 Point）或者指向类型的指针上定义，但是多亏了内嵌，有些时候我们给匿名 struct 类型来定义方法也有了手段。</p><p>下面是一个小 trick。这个例子展示了简单的 cache：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    mapping <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    mapping: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    cache.Lock()</span><br><span class="line">    v := cache.mapping[key]</span><br><span class="line">    cache.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4-方法值和方法表达式"><a href="#6-4-方法值和方法表达式" class="headerlink" title="6.4. 方法值和方法表达式"></a>6.4. 方法值和方法表达式</h2><p>我们经常选择一个方法，并且在同一个表达式里执行，比如常见的 <code>p.Distance()</code> 形式，实际上将其分成两步来执行也是可能的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">distanceFromP := p.Distance        <span class="comment">// method value</span></span><br><span class="line">fmt.Println(distanceFromP(q))      <span class="comment">// "5"</span></span><br><span class="line"><span class="keyword">var</span> origin Point                   <span class="comment">// &#123;0, 0&#125;</span></span><br><span class="line">fmt.Println(distanceFromP(origin)) <span class="comment">// "2.23606797749979", sqrt(5)</span></span><br></pre></td></tr></table></figure><p>我们将 <code>distanceFromP</code> 称为 <code>Distance</code> 绑定了接受者 <code>p</code> 上的方法值。</p><p>和方法 “值” 相关的还有方法表达式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">distance := Point.Distance   <span class="comment">// method expression</span></span><br><span class="line">fmt.Println(distance(p, q))  <span class="comment">// "5"</span></span><br></pre></td></tr></table></figure><h2 id="6-6-封装"><a href="#6-6-封装" class="headerlink" title="6.6. 封装"></a>6.6. 封装</h2><p>封装提供了三方面的优点。首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可。</p><p>第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的 api 情况下能得到更大的自由。</p><p>把 <code>bytes.Buffer</code> 这个类型作为例子来考虑。这个类型在做短字符串叠加的时候很常用，所以在设计的时候可以做一些预先的优化，比如提前预留一部分空间，来避免反复的内存分配。又因为 Buffer 是一个 struct 类型，这些额外的空间可以用附加的字节数组来保存，且放在一个小写字母开头的字段中。这样在外部的调用方只能看到性能的提升，但并不会看得到这个附加变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Buffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    buf     []<span class="keyword">byte</span></span><br><span class="line">    initial [<span class="number">64</span>]<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装的第三个优点也是最重要的优点，是阻止了外部调用方对对象内部的值任意地进行修改。</p><p>封装并不总是理想的。 虽然封装在有些情况是必要的，但有时候我们也需要暴露一些内部内容，比如：<code>time.Duration</code> 将其表现暴露为一个 <code>int64</code> 数字的纳秒，使得我们可以用一般的数值操作来对时间进行对比，甚至可以定义这种类型的常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> day = <span class="number">24</span> * time.Hour</span><br><span class="line">fmt.Println(day.Seconds()) <span class="comment">// "86400"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;6-1-方法声明&quot;&gt;&lt;a href=&quot;#6-1-方法声明&quot; class=&quot;headerlink&quot; title=&quot;6.1. 方法声明&quot;&gt;&lt;/a&gt;6.1. 方法声明&lt;/h2&gt;&lt;p&gt;在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种
      
    
    </summary>
    
      <category term="Go 语言圣经" scheme="https://homholueng.github.io/categories/Go-%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"/>
    
    
      <category term="Go" scheme="https://homholueng.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言圣经 - 5. 函数</title>
    <link href="https://homholueng.github.io/2019/08/05/gopl-function/"/>
    <id>https://homholueng.github.io/2019/08/05/gopl-function/</id>
    <published>2019-08-05T13:33:25.000Z</published>
    <updated>2019-08-05T13:33:25.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5-1-函数声明"><a href="#5-1-函数声明" class="headerlink" title="5.1. 函数声明"></a>5.1. 函数声明</h2><p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(parameter-list)</span> <span class="params">(result-list)</span></span> &#123;</span><br><span class="line">    body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值也可以像形式参数一样被命名。在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为该类型的零值。 如果一个函数在声明时，包含返回值列表，该函数必须以 <code>return</code> 语句结尾，除非函数明显无法运行到结尾处。</p><p>如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。下面 2 个声明是等价的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i, j, k <span class="keyword">int</span>, s, t <span class="keyword">string</span>)</span></span>                 &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>, j <span class="keyword">int</span>, k <span class="keyword">int</span>,  s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>函数的类型被称为函数的签名。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或签名。形参和返回值的变量名不影响函数签名，也不影响它们是否可以以省略参数类型的形式表示。</p><p>实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice (切片)、map、function、channel 等类型，实参可能会由于函数的间接引用被修改。</p><p>你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以 Go 实现的。这样的声明定义了函数签名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sin</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float</span> //<span class="title">implemented</span> <span class="title">in</span> <span class="title">assembly</span> <span class="title">language</span></span></span><br></pre></td></tr></table></figure><h2 id="5-3-多返回值"><a href="#5-3-多返回值" class="headerlink" title="5.3. 多返回值"></a>5.3. 多返回值</h2><p>调用多返回值函数时，返回给调用者的是一组值，调用者必须显式的将这些值分配给变量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">links, err := findLinks(url)</span><br></pre></td></tr></table></figure><p>如果某个值不被使用，可以将其分配给 blank identifier:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">links, _ := findLinks(url) <span class="comment">// errors ignored</span></span><br></pre></td></tr></table></figure><p>当你调用接受多参数的函数时，可以将一个返回多参数的函数调用作为该函数的参数。虽然这很少出现在实际生产代码中，但这个特性在 debug 时很方便，我们只需要一条语句就可以输出所有的返回值。下面的代码是等价的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.Println(findLinks(url))</span><br><span class="line">links, err := findLinks(url)</span><br><span class="line">log.Println(links, err)</span><br></pre></td></tr></table></figure><p><em>如果一个函数所有的返回值都有显式的变量名，那么该函数的 return 语句可以省略操作数。这称之为 bare return。</em></p><p><strong>当一个函数有多处 return 语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。</strong></p><h2 id="5-4-错误"><a href="#5-4-错误" class="headerlink" title="5.4. 错误"></a>5.4. 错误</h2><p>通常，导致失败的原因不止一种，尤其是对 I/O 操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是 error 类型，内置的 error 是接口类型。</p><p>通常，当函数返回 non-nil 的 error 时，其他的返回值是未定义的（undefined），这些未定义的返回值应该被忽略。然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，<code>Read</code> 函数会返回可以读取的字节数以及错误信息。</p><h3 id="5-4-1-错误处理策略"><a href="#5-4-1-错误处理策略" class="headerlink" title="5.4.1. 错误处理策略"></a>5.4.1. 错误处理策略</h3><p>当一次函数调用返回错误时，调用者应该选择合适的方式处理错误。根据情况的不同，有很多处理方式，让我们来看看常用的五种方式。</p><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>首先，也是最常用的方式是传播错误。这意味着函数中某个子程序的失败，会变成该函数的失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当对 <code>html.Parse</code> 的调用失败时，<code>findLinks</code> 不会直接返回 <code>html.Parse</code> 的错误，因为缺少两条重要信息：1、发生错误时的解析器（html parser）；2、发生错误的 url。因此，findLinks 构造了一个新的错误信息，既包含了这两项，也包括了底层的解析出错的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doc, err := html.Parse(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"parsing %s as HTML: %v"</span>, url,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用该函数添加额外的前缀上下文信息到原始错误信息。当错误最终由 <code>main</code> 函数处理时，错误信息应提供清晰的从原因到后果的因果链，就像美国宇航局事故调查时做的那样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genesis: crashed: no parachute: G-switch failed: bad relay orientation</span><br></pre></td></tr></table></figure><p>由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。</p><p>编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。</p><p>以 os 包为例，os 包确保文件操作（如 <code>os.Open</code>、<code>Read</code>、<code>Write</code>、<code>Close</code>）返回的每个错误的描述不仅仅包含错误的原因（如无权限，文件目录不存在）也包含文件名，这样调用者在构造新的错误信息时无需再添加这些信息。</p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。</p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。需要注意的是，这种策略只应在 <code>main</code> 中执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (In function main.)</span></span><br><span class="line"><span class="keyword">if</span> err := WaitForServer(url); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintf(os.Stderr, <span class="string">"Site is down: %v\n"</span>, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>log.Fatalf</code> 可以更简洁的代码达到与上文相同的效果。log 中的所有函数，都默认会在错误信息之前输出时间信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := WaitForServer(url); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">"Site is down: %v\n"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>第四种策略：有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。我们可以通过 log 包提供函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"ping failed: %v; networking disabled"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者标准错误流输出错误信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintf(os.Stderr, <span class="string">"ping failed: %v; networking disabled\n"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>log 包中的所有函数会为没有换行符的字符串增加换行符。</p><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>第五种，也是最后一种策略：我们可以直接忽略掉错误。</p><h3 id="5-4-2-文件结尾错误（EOF）"><a href="#5-4-2-文件结尾错误（EOF）" class="headerlink" title="5.4.2. 文件结尾错误（EOF）"></a>5.4.2. 文件结尾错误（EOF）</h3><p>io 包保证任何由文件结束引起的读取失败都返回同一个错误 —— <code>io.EOF</code>，该错误在 io 包中定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package io</span><br><span class="line"></span><br><span class="line">import &quot;errors&quot;</span><br><span class="line"></span><br><span class="line">// EOF is the error returned by Read when no more input is available.</span><br><span class="line">var EOF = errors.New(&quot;EOF&quot;)</span><br></pre></td></tr></table></figure><h2 id="5-5-函数值"><a href="#5-5-函数值" class="headerlink" title="5.5. 函数值"></a>5.5. 函数值</h2><p>在 Go 中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> n * n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">negative</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> -n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">product</span><span class="params">(m, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> m * n &#125;</span><br><span class="line"></span><br><span class="line">f := square</span><br><span class="line">fmt.Println(f(<span class="number">3</span>)) <span class="comment">// "9"</span></span><br><span class="line"></span><br><span class="line">f = negative</span><br><span class="line">fmt.Println(f(<span class="number">3</span>))     <span class="comment">// "-3"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, f) <span class="comment">// "func(int) int"</span></span><br><span class="line"></span><br><span class="line">f = product <span class="comment">// compile error: can't assign func(int, int) int to func(int) int</span></span><br></pre></td></tr></table></figure><p>函数类型的零值是 <code>nil</code>，函数值可以与 <code>nil</code> 比较。</p><p>但是函数值之间是不可比较的，也不能用函数值作为 map 的 key。</p><h2 id="5-6-匿名函数"><a href="#5-6-匿名函数" class="headerlink" title="5.6. 匿名函数"></a>5.6. 匿名函数</h2><p>拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值。</p><p>函数字面量允许我们在使用函数时，再定义它。通过这种技巧，我们可以改写之前对 <code>strings.Map</code> 的调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Map(<span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span> &#123;<span class="keyword">return</span> r + <span class="number">1</span>&#125;, <span class="string">"HAL-9000"</span>)</span><br></pre></td></tr></table></figure><p>更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量，如下例所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        x++</span><br><span class="line">        <span class="keyword">return</span> x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := squares()</span><br><span class="line">    fmt.Println(f()) <span class="comment">// "1"</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "4"</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "9"</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "16"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>squares</code> 的例子证明，函数值不仅仅是一串代码，还记录了状态。在 squares 中定义的匿名内部函数可以访问和更新 <code>squares</code> 中的局部变量，这意味着匿名函数和 <code>squares</code> 中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go 使用闭包（closures）技术实现函数值，Go 程序员也把函数值叫做闭包。</p><p>当匿名函数需要被递归调用时，我们必须首先声明一个变量，再将匿名函数赋值给这个变量。如果不分成两步，函数字面量无法与特定变量绑定，我们也无法递归调用该匿名函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> visitAll <span class="function"><span class="keyword">func</span><span class="params">(items []<span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">visitAll</span> = <span class="title">func</span><span class="params">(items []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    visitAll(items)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-1-警告：捕获迭代变量"><a href="#5-6-1-警告：捕获迭代变量" class="headerlink" title="5.6.1. 警告：捕获迭代变量"></a>5.6.1. 警告：捕获迭代变量</h3><blockquote><p>本节，将介绍 Go 词法作用域的一个陷阱。请务必仔细的阅读，弄清楚发生问题的原因。即使是经验丰富的程序员也会在这个问题上犯错误。</p></blockquote><p>考虑这样一个问题：你被要求首先创建一些目录，再将目录删除。在下面的例子中我们用函数值来完成删除操作。下面的示例代码需要引入 <code>os</code> 包。为了使代码简单，我们忽略了所有的异常处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> _, <span class="title">d</span> := <span class="title">range</span> <span class="title">tempDirs</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dir := d <span class="comment">// <span class="doctag">NOTE:</span> necessary!</span></span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>) <span class="comment">// creates parent directories too</span></span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dir)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...do some work…</span></span><br><span class="line"><span class="keyword">for</span> _, rmdir := <span class="keyword">range</span> rmdirs &#123;</span><br><span class="line">    rmdir() <span class="comment">// clean up</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会感到困惑，为什么要在循环体中用循环变量 <code>d</code> 赋值一个新的局部变量，而不是像下面的代码一样直接使用循环变量 <code>dir</code>。</p><p>问题的原因在于循环变量的作用域。在上面的程序中，<code>for</code> 循环语句引入了新的词法块，循环变量 <code>dir</code> 在这个词法块中被声明。在该循环中生成的所有函数值都共享相同的循环变量。需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。以 <code>dir</code> 为例，后续的迭代会不断更新 <code>dir</code> 的值，当删除操作执行时，<code>for</code> 循环已完成，<code>dir</code> 中存储的值等于最后一次迭代的值。这意味着，每次对 <code>os.RemoveAll</code> 的调用删除的都是相同的目录。</p><p>通常，为了解决这个问题，我们会引入一个与循环变量同名的局部变量，作为循环变量的副本。比如下面的变量 <code>dir</code>，虽然这看起来很奇怪，但却很有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, dir := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    dir := dir <span class="comment">// declares inner dir, initialized to outer dir</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题不仅存在基于 <code>range</code> 的循环，在三段式的 <code>for</code> 循环中，也会存在这样的问题。</p><h2 id="5-7-可变参数"><a href="#5-7-可变参数" class="headerlink" title="5.7. 可变参数"></a>5.7. 可变参数</h2><p>参数数量可变的函数称为可变参数函数。</p><p>在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号 <code>...</code>，这表示该函数会接收任意数量的该类型参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(vals...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">        total += val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数体中，<code>vals</code> 被看作是类型为 <code>[]int</code> 的切片。<code>sum</code> 可以接收任意数量的 <code>int</code> 型参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>在上面的代码中，调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调用函数。如果原始参数已经是切片类型，我们该如何传递给 <code>sum</code>？只需在最后一个参数后加上省略符。下面的代码功能与上个例子相同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(sum(values...)) <span class="comment">// "10"</span></span><br></pre></td></tr></table></figure><h2 id="5-8-Deferred-函数"><a href="#5-8-Deferred-函数" class="headerlink" title="5.8. Deferred 函数"></a>5.8. Deferred 函数</h2><p>你只需要在调用普通函数或方法前加上关键字 <code>defer</code>，就完成了 <code>defer</code> 所需要的语法。 <strong>当执行到该条语句时，函数和参数表达式得到计算，但直到包含该 <code>defer</code> 语句的函数执行完毕时，<code>defer</code> 后的函数才会被执行，不论包含 <code>defer</code> 语句的函数是通过 <code>return</code> 正常结束，还是由于 panic 导致的异常结束。</strong> 你可以在一个函数中执行多条 <code>defer</code> 语句，它们的执行顺序与声明顺序相反。</p><p><code>defer</code> 语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过 <code>defer</code> 机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。</p><p>调试复杂程序时，defer 机制也常被用于记录何时进入和退出函数。下例中的 <code>bigSlowOperation</code> 函数，直接调用 <code>trace</code> 记录函数的被调情况。<strong>需要注意一点：不要忘记 <code>defer</code> 语句后的圆括号，否则本该在进入时执行的操作会在退出时执行，而本该在退出时执行的，永远不会被执行。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bigSlowOperation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> trace(<span class="string">"bigSlowOperation"</span>)() <span class="comment">// don't forget the extra parentheses</span></span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    log.Printf(<span class="string">"enter: %s"</span>, msg)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"exit %s (%s)"</span>, msg, time.Since(start))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，<code>defer</code> 语句中的函数会在 <code>return</code> 语句更新返回值变量后再执行，又因为在函数中定义的匿名函数可以访问该函数包括返回值变量在内的所有变量，所以，对匿名函数采用 defer 机制，可以使其观察函数的返回值。</p><p>被延迟执行的匿名函数甚至可以修改函数返回给调用者的返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">triple</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; result += x &#125;()</span><br><span class="line">    <span class="keyword">return</span> double(x)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(triple(<span class="number">4</span>)) <span class="comment">// "12"</span></span><br></pre></td></tr></table></figure><p>在循环体中的 <code>defer</code> 语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行。下面的代码会导致系统的文件描述符耗尽，因为在所有文件都被处理之前，没有文件会被关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close() <span class="comment">// <span class="doctag">NOTE:</span> risky; could run out of file descriptors</span></span><br><span class="line">    <span class="comment">// ...process f…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-9-Panic-异常"><a href="#5-9-Panic-异常" class="headerlink" title="5.9. Panic 异常"></a>5.9. Panic 异常</h2><p>Go 的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起 <code>painc</code> 异常。</p><p>一般而言，当 panic 异常发生时，程序会中断运行，并立即执行在该 goroutine 中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。日志信息包括 panic value 和函数调用的堆栈跟踪信息。panic value 通常是某种错误信息。对于每个 goroutine，日志信息中都会有与之相对的，发生 panic 时的函数调用堆栈跟踪信息。</p><p>不是所有的 panic 异常都来自运行时，直接调用内置的 <code>panic</code> 函数也会引发 panic 异常；panic 函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用 panic。比如，当程序到达了某条逻辑上不可能到达的路径：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> s := suit(drawCard()); s &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Spades"</span>:                                <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Hearts"</span>:                                <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Diamonds"</span>:                              <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Clubs"</span>:                                 <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"invalid suit %q"</span>, s)) <span class="comment">// Joker?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 Go 的 panic 机制类似于其他语言的异常，但 panic 的适用场景有一些不同。由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致。勤奋的程序员认为任何崩溃都表明代码中存在漏洞，所以对于大部分漏洞，我们应该使用 Go 提供的错误机制，而不是 panic，尽量避免程序的崩溃。在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的 I/O 操作都应该被优雅的处理，最好的处理方式，就是使用 Go 的错误机制。但是在某些场景下，我们希望程序一定不能抛出错误，否则就引发 panic，go 的标准库中为了满足这种情况，许多函数都提供了 <code>Must</code> 前缀的包装版本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> regexp</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(expr <span class="keyword">string</span>)</span> <span class="params">(*Regexp, error)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MustCompile</span><span class="params">(expr <span class="keyword">string</span>)</span> *<span class="title">Regexp</span></span> &#123;</span><br><span class="line">    re, err := Compile(expr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便诊断问题，<code>runtime</code> 包允许程序员输出堆栈信息。在下面的例子中，我们通过在 <code>main</code> 函数中延迟调用 <code>printStack</code> 输出堆栈信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> printStack()</span><br><span class="line">    f(<span class="number">3</span>) <span class="comment">// will panic</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf [<span class="number">4096</span>]<span class="keyword">byte</span></span><br><span class="line">    n := runtime.Stack(buf[:], <span class="literal">false</span>)</span><br><span class="line">    os.Stdout.Write(buf[:n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-10-Recover-捕获异常"><a href="#5-10-Recover-捕获异常" class="headerlink" title="5.10. Recover 捕获异常"></a>5.10. Recover 捕获异常</h2><p>通常来说，不应该对 panic 异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当 web 服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭；如果不做任何处理，会使得客户端一直处于等待状态。如果 web 服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。</p><p>如果在 deferred 函数中调用了内置函数 <code>recover</code>，并且定义该 <code>defer</code> 语句的函数发生了 panic 异常，<code>recover</code> 会使程序从 panic 中恢复，并返回 panic value。导致 panic 异常的函数不会继续运行，但能正常返回。在未发生 panic 时调用 <code>recover</code>，<code>recover</code> 会返回 <code>nil</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicFunc</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">err = fmt.Errorf(<span class="string">"internal error: %v"</span>, p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(panicFunc(<span class="number">0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不加区分的恢复所有的 panic 异常，不是可取的做法；因为在 panic 之后，无法保证包级变量的状态仍然和我们预期一致。比如，对数据结构的一次重要更新没有被完整完成、文件或者网络连接没有被关闭、获得的锁没有被释放。此外，如果写日志时产生的 panic 被不加区分的恢复，可能会导致漏洞被忽略。</p><p>虽然把对 panic 的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的 panic。公有的 API 应该将函数的运行失败作为 error 返回，而不是 panic。同样的，你也不应该恢复一个由他人开发的函数引起的 panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;5-1-函数声明&quot;&gt;&lt;a href=&quot;#5-1-函数声明&quot; class=&quot;headerlink&quot; title=&quot;5.1. 函数声明&quot;&gt;&lt;/a&gt;5.1. 函数声明&lt;/h2&gt;&lt;p&gt;函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="Go 语言圣经" scheme="https://homholueng.github.io/categories/Go-%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"/>
    
    
      <category term="Go" scheme="https://homholueng.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言圣经 - 4. 复合数据类型</title>
    <link href="https://homholueng.github.io/2019/07/31/gopl-complex-type/"/>
    <id>https://homholueng.github.io/2019/07/31/gopl-complex-type/</id>
    <published>2019-07-31T15:15:15.000Z</published>
    <updated>2019-08-05T12:04:36.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1. 数组"></a>4.1. 数组</h2><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，因此在Go语言中很少直接使用数组。</p><p>默认情况下，数组的每个元素都被初始化为元素类型对应的零值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">3</span>]<span class="keyword">int</span>  <span class="comment">// array of 3 intergers with 0 value</span></span><br></pre></td></tr></table></figure><p>我们也可以使用数组字面值语法用一组值来初始化数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> r [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(r[<span class="number">2</span>]) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>在数组字面值中，如果在数组的长度位置出现的是 <code>...</code> 省略号，则表示数组的长度是根据初始化值的个数来计算：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>数组的长度是数组类型的一个组成部分，因此 <code>[3]int</code> 和 <code>[4]int</code> 是两种不同的数组类型。</p><p>数组也可以指定一个索引和对应值列表的方式初始化，在这种形式的数组字面值形式中，初始化索引的顺序是无关紧要的，而且没用到的索引可以省略，和前面提到的规则一样，未指定初始值的元素将用零值初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Currency <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    USD Currency = <span class="literal">iota</span> <span class="comment">// 美元</span></span><br><span class="line">    EUR                 <span class="comment">// 欧元</span></span><br><span class="line">    GBP                 <span class="comment">// 英镑</span></span><br><span class="line">    RMB                 <span class="comment">// 人民币</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">symbol := [...]<span class="keyword">string</span>&#123;USD: <span class="string">"$"</span>, EUR: <span class="string">"€"</span>, GBP: <span class="string">"￡"</span>, RMB: <span class="string">"￥"</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(RMB, symbol[RMB]) <span class="comment">// "3 ￥"</span></span><br></pre></td></tr></table></figure><p>如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过 <code>==</code> 比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。</p><p><strong>注意，GO 并不会隐式的将传递给函数参数的数组转换成为指针，如果函数需要接收一个数组并修改其内容，则需要显示的将其参数类型声明为数组指针。</strong></p><p>因为数组的类型包含了僵化的长度信息，并且不同长度的数组也被认作不同的类型，所以 GO 中很少直接使用数组，而是使用 <code>slice</code>。</p><h2 id="4-2-Slice"><a href="#4-2-Slice" class="headerlink" title="4.2. Slice"></a>4.2. Slice</h2><p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个 slice 类型一般写作 <code>[]T</code>，其中 <code>T</code> 代表 slice 中元素的类型；slice 的语法和数组很像，只是没有固定长度而已。</p><p>数组和 slice 之间有着紧密的联系。一个 slice 是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且 slice 的底层确实引用一个数组对象。</p><p><strong>一个 slice 由三个部分构成：指针、长度和容量。</strong></p><p>下图显示了表示一年中每个月份名字的字符串数组，还有重叠引用了该数组的两个 slice。数组这样定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">months := [...]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">"January"</span>, <span class="comment">/* ... */</span>, <span class="number">12</span>: <span class="string">"December"</span>&#125;</span><br></pre></td></tr></table></figure><img src="/2019/07/31/gopl-complex-type/slice-on-array.png" title="[切片示例]"><p>slice 的切片操作 <code>s[i:j]</code>，其中 <code>0 ≤ i≤ j≤ cap(s)</code>，用于创建一个新的 slice，引用 <code>s</code> 的从第 <code>i</code> 个元素开始到第 <code>j-1</code> 个元素的子序列。</p><p>如果切片操作超出 <code>cap(s)</code> 的上限将导致一个 panic 异常，但是超出 <code>len(s)</code> 则是意味着扩展了 slice，因为新 slice 的长度会变大：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">fmt.Println(s) <span class="comment">// [1 2]</span></span><br><span class="line">fmt.Printf(<span class="string">"len: %d, cap: %d\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">new_s := s[:<span class="number">4</span>] <span class="comment">// len: 2, cap: 5</span></span><br><span class="line">fmt.Printf(<span class="string">"len: %d, cap: %d\n"</span>, <span class="built_in">len</span>(new_s), <span class="built_in">cap</span>(new_s)) <span class="comment">// len: 4, cap: 5</span></span><br></pre></td></tr></table></figure><p>因为 slice 值包含指向第一个 slice 元素的指针，因此向函数传递 slice 将允许在函数内部修改底层数组的元素。</p><p>要注意的是 slice 类型的变量 s 和数组类型的变量 a 的初始化语法的差异。slice 和数组的字面值语法很类似，它们都是用花括弧包含一系列的初始化元素，但是对于 slice 并没有指明序列的长度。<strong>这会隐式地创建一个合适大小的数组，然后 slice 的指针指向底层的数组</strong>。就像数组字面值一样，slice 的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定，或者用两种风格的混合语法初始化。</p><p>和数组不同的是，slice 之间不能比较，因此我们不能使用 <code>==</code> 操作符来判断两个 slice 是否含有全部相等元素。</p><p><strong>slice 唯一合法的比较操作是和 nil 比较，如果你需要测试一个 slice 是否是空的，使用 len (s) == 0 来判断，而不应该用 s == nil 来判断。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span>    <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = <span class="literal">nil</span>        <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="keyword">int</span>(<span class="literal">nil</span>) <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="keyword">int</span>&#123;&#125;    <span class="comment">// len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure><p>内置的 <code>make</code> 函数创建一个指定元素类型、长度和容量的 slice。容量部分可以省略，在这种情况下，容量将等于长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>) <span class="comment">// same as make([]T, cap)[:len]</span></span><br></pre></td></tr></table></figure><h3 id="4-2-1-append-函数"><a href="#4-2-1-append-函数" class="headerlink" title="4.2.1. append 函数"></a>4.2.1. append 函数</h3><p>内置的 <code>append</code> 函数用于向 slice 追加元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var runes []rune</span><br><span class="line">for _, r := range &quot;Hello, 世界&quot; &#123;</span><br><span class="line">    runes = append(runes, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%q\n&quot;, runes) // &quot;[&apos;H&apos; &apos;e&apos; &apos;l&apos; &apos;l&apos; &apos;o&apos; &apos;,&apos; &apos; &apos; &apos;世&apos; &apos;界&apos;]&quot;</span><br></pre></td></tr></table></figure><p>内置的 copy 函数可以方便地将一个 slice 复制另一个相同类型的 slice，<code>copy</code> 函数的第一个参数是要复制的目标 slice，第二个参数是源 slice，目标和源的位置顺序和 <code>dst = src</code> 赋值语句是一致的。</p><p><strong>我们并不知道 <code>append</code> 调用是否导致了内存的重新分配，因此我们也不能确认新的 slice 和原始的 slice 是否引用的是相同的底层数组空间。同样，我们不能确认在原先的 slice 上的操作是否会影响到新的 slice。</strong> 因此，通常是将 append 返回的结果直接赋值给输入的 slice 变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runes = <span class="built_in">append</span>(runes, r)</span><br></pre></td></tr></table></figure><p><code>append</code> 函数则可以追加多个元素，甚至追加一个 slice。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x []<span class="keyword">int</span></span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">1</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, x...) <span class="comment">// append the slice x</span></span><br><span class="line">fmt.Println(x)      <span class="comment">// "[1 2 3 4 5 6 1 2 3 4 5 6]"</span></span><br></pre></td></tr></table></figure><h3 id="4-2-2-Slice-内存技巧"><a href="#4-2-2-Slice-内存技巧" class="headerlink" title="4.2.2. Slice 内存技巧"></a>4.2.2. Slice 内存技巧</h3><p> 给定一个字符串列表，下面的 <code>nonempty</code> 函数将在原有 slice 内存空间之上返回不包含空字符串的列表：</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Nonempty is an example of an in-place slice algorithm.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nonempty returns a slice holding only the non-empty strings.</span></span><br><span class="line"><span class="comment">// The underlying array is modified during the call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nonempty</span><span class="params">(strings []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> strings &#123;</span><br><span class="line">        <span class="keyword">if</span> s != <span class="string">""</span> &#123;</span><br><span class="line">            strings[i] = s</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strings[:i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 比较微妙的地方是，输入的 slice 和输出的 slice 共享一个底层数组。这可以避免分配另一个数组，不过原来的数据将可能会被覆盖，正如下面两个打印语句看到的那样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>, <span class="string">""</span>, <span class="string">"three"</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, nonempty(data)) <span class="comment">// `["one" "three"]`</span></span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, data)           <span class="comment">// `["one" "three" "three"]`</span></span><br></pre></td></tr></table></figure><p>因此我们通常会这样使用 <code>nonempty</code> 函数：<code>data = nonempty(data)</code>。</p><h2 id="4-3-Map"><a href="#4-3-Map" class="headerlink" title="4.3. Map"></a>4.3. Map</h2><p>在 Go 语言中，一个 map 就是一个哈希表的引用，map 类型可以写为 <code>map[K]V</code>，其中 <code>K</code> 和 <code>V</code> 分别对应 key 和 value。</p><p>内置的 make 函数可以创建一个 map：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">// mapping from strings to ints</span></span><br></pre></td></tr></table></figure><p>我们也可以用 map 字面值的语法创建 map，同时还可以指定一些最初的 key/value：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"alice"</span>:   <span class="number">31</span>,</span><br><span class="line">    <span class="string">"charlie"</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用内置的 <code>delete</code> 函数可以删除元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(ages, <span class="string">"alice"</span>) <span class="comment">// remove element ages["alice"]</span></span><br></pre></td></tr></table></figure><p><strong>在 go 的 map 上，如果一个查找失败将返回 value 类型对应的零值。</strong></p><p>但是 map 中的元素并不是一个变量，因此我们不能对 map 的元素进行取址操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = &amp;ages[<span class="string">"bob"</span>] <span class="comment">// compile error: cannot take address of map element</span></span><br></pre></td></tr></table></figure><p>禁止对 map 元素取址的原因是 map 可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</p><p>要想遍历 map 中全部的 key/value 对的话，可以使用 range 风格的 for 循环实现，和之前的 slice 遍历语法类似。下面的迭代语句将在每次迭代时设置 name 和 age 变量，它们对应下一个键 / 值对：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, age := <span class="keyword">range</span> ages &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s\t%d\n"</span>, name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要按顺序遍历 key/value 对，我们必须显式地对 key 进行排序，可以使用 sort 包的 Strings 函数对字符串 slice 进行排序。下面是常见的处理方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sort"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> name := <span class="keyword">range</span> ages &#123;</span><br><span class="line">    names = <span class="built_in">append</span>(names, name)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(names)</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s\t%d\n"</span>, name, ages[name])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们一开始就知道 names 的最终大小，因此给 slice 分配一个合适的大小将会更有效。下面的代码创建了一个空的 slice，但是 slice 的容量刚好可以放下 map 中全部的 key：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(ages)) <span class="comment">// type, len, cap</span></span><br></pre></td></tr></table></figure><p>map 类型的零值是 <code>nil</code>，也就是没有引用任何哈希表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ages <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(ages == <span class="literal">nil</span>)    <span class="comment">// "true"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(ages) == <span class="number">0</span>) <span class="comment">// "true"</span></span><br></pre></td></tr></table></figure><p>map 上的大部分操作，包括查找、删除、<code>len</code> 和 <code>range</code> 循环都可以安全工作在 <code>nil</code> 值的 map 上，它们的行为和一个空的 map 类似。但是向一个 <code>nil</code> 值的 map 存入元素将导致一个 panic 异常：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">"carol"</span>] = <span class="number">21</span> <span class="comment">// panic: assignment to entry in nil map</span></span><br></pre></td></tr></table></figure><p>如果我们需要确认 map 取值返回的究竟是不存在的零值还是存在的零值，可以使用如下的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">age, ok := ages[<span class="string">"bob"</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="comment">/* "bob" is not a key in this map; age == 0. */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age, ok := ages[<span class="string">"bob"</span>]; !ok &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>和 slice 一样，map 之间也不能进行相等比较；唯一的例外是和 <code>nil</code> 进行比较。要判断两个 map 是否包含相同的 key 和 value，我们必须通过一个循环实现。</p><p>Go 语言中并没有提供一个 set 类型，但是 map 中的 key 也是不相同的，可以用 map 实现类似 set 的功能。</p><p>有时候我们需要一个 map 或 set 的 key 是 slice 类型，但是 map 的 key 必须是可比较的类型，但是 slice 并不满足这个条件。不过，我们可以通过两个步骤绕过这个限制。第一步，定义一个辅助函数 <code>k</code>，将 slice 转为 map 对应的 string 类型的 key，确保只有 <code>x</code> 和 <code>y</code> 相等时 <code>k (x) == k (y)</code> 才成立。然后创建一个 key 为 string 类型的 map，在每次对 map 操作时先用 <code>k</code> 辅助函数将 slice 转化为 string 类型。</p><h2 id="4-4-结构体"><a href="#4-4-结构体" class="headerlink" title="4.4. 结构体"></a>4.4. 结构体</h2><p>结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。</p><p>下面两个语句声明了一个叫 Employee 的命名的结构体类型，并且声明了一个 Employee 类型的变量 <code>dilbert</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="keyword">int</span></span><br><span class="line">    Name      <span class="keyword">string</span></span><br><span class="line">    Address   <span class="keyword">string</span></span><br><span class="line">    DoB       time.Time</span><br><span class="line">    Position  <span class="keyword">string</span></span><br><span class="line">    Salary    <span class="keyword">int</span></span><br><span class="line">    ManagerID <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dilbert Employee</span><br></pre></td></tr></table></figure><p><code>dilbert</code> 结构体变量的成员可以通过点操作符访问，比如 <code>dilbert.Name</code> 和 <code>dilbert.DoB</code>。</p><p>点操作符也可以和指向结构体的指针一起工作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeeOfTheMonth *Employee = &amp;dilbert</span><br><span class="line">employeeOfTheMonth.Position += <span class="string">" (proactive team player)"</span></span><br></pre></td></tr></table></figure><p>相当于下面语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*employeeOfTheMonth).Position += <span class="string">" (proactive team player)"</span></span><br></pre></td></tr></table></figure><p>下面的 <code>EmployeeByID</code> 函数将根据给定的员工 ID 返回对应的员工信息结构体的指针。我们可以使用点操作符来访问它里面的成员：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EmployeeByID</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">Employee</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(EmployeeByID(dilbert.ManagerID).Position) <span class="comment">// "Pointy-haired boss"</span></span><br><span class="line"></span><br><span class="line">id := dilbert.ID</span><br><span class="line">EmployeeByID(id).Salary = <span class="number">0</span> <span class="comment">// fired for... no real reason</span></span><br></pre></td></tr></table></figure><p>后面的语句通过 <code>EmployeeByID</code> 返回的结构体指针更新了 <code>Employee</code> 结构体的成员。如果将 <code>EmployeeByID</code> 函数的返回值从 <code>*Employee</code> 指针类型改为 <code>Employee</code> 值类型，那么更新语句将不能编译通过，因为在赋值语句的左边并不确定是一个变量（译注：调用函数返回的是值，并不是一个可取地址的变量）。</p><p>通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行，就像下面的 Name 和 Address 成员那样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID            <span class="keyword">int</span></span><br><span class="line">    Name, Address <span class="keyword">string</span></span><br><span class="line">    DoB           time.Time</span><br><span class="line">    Position      <span class="keyword">string</span></span><br><span class="line">    Salary        <span class="keyword">int</span></span><br><span class="line">    ManagerID     <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是 Go 语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。</strong></p><p>结构体类型的零值是每个成员都是零值。通常会将零值作为最合理的默认值。</p><p>如果结构体没有任何成员的话就是空结构体，写作 <code>struct{}</code>。它的大小为 0，也不包含任何信息，但是有时候依然是有价值的。有些 Go 语言程序员用 map 来模拟 set 数据结构时，用它来代替 map 中布尔类型的 value，只是强调 key 的重要性，但是因为节约的空间有限，而且语法比较复杂，所以我们通常会避免这样的用法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;) <span class="comment">// set of strings</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> _, ok := seen[s]; !ok &#123;</span><br><span class="line">    seen[s] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="comment">// ...first time seeing s...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-1-结构体字面值"><a href="#4-4-1-结构体字面值" class="headerlink" title="4.4.1. 结构体字面值"></a>4.4.1. 结构体字面值</h3><p>结构体值也可以用结构体字面值表示，结构体字面值可以指定每个成员的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">int</span> &#125;</span><br><span class="line"></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>这里有两种形式的结构体字面值语法，上面的是第一种写法，要求以结构体成员定义的顺序为每个结构体成员指定一个字面值。它要求写代码和读代码的人要记住结构体的每个成员的类型和顺序，不过结构体成员有细微的调整就可能导致上述代码不能编译。</p><p>其实更常用的是第二种写法，以成员名字和相应的值来初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;X: <span class="number">1</span>, Y: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>在这种形式的结构体字面值写法中，如果成员被忽略的话将默认用零值。另外，需要注意的是，两种不同形式的写法不能混合使用。</p><p>因为结构体通常通过指针处理，可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pp := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>它和下面的语句是等价的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pp := <span class="built_in">new</span>(Point)</span><br><span class="line">*pp = Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>不过 <code>&amp;Point{1, 2}</code> 写法可以直接在表达式中使用，比如一个函数调用。</p><h3 id="4-4-2-结构体比较"><a href="#4-4-2-结构体比较" class="headerlink" title="4.4.2. 结构体比较"></a>4.4.2. 结构体比较</h3><p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用 <code>==</code> 或 <code>=</code> 运算符进行比较。</p><p>可比较的结构体类型和其他可比较的类型一样，可以用于 map 的 key 类型。</p><h3 id="4-4-3-结构体嵌入和匿名成员"><a href="#4-4-3-结构体嵌入和匿名成员" class="headerlink" title="4.4.3. 结构体嵌入和匿名成员"></a>4.4.3. 结构体嵌入和匿名成员</h3><p>Go 语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。下面的代码中，Circle 和 Wheel 各自都有一个匿名成员。我们可以说 Point 类型被嵌入到了 Circle 结构体，同时 Circle 类型被嵌入到了 Wheel 结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Radius <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Circle</span><br><span class="line">    Spokes <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得益于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.X = <span class="number">8</span>            <span class="comment">// equivalent to w.Circle.Point.X = 8</span></span><br><span class="line">w.Y = <span class="number">8</span>            <span class="comment">// equivalent to w.Circle.Point.Y = 8</span></span><br><span class="line">w.Radius = <span class="number">5</span>       <span class="comment">// equivalent to w.Circle.Radius = 5</span></span><br><span class="line">w.Spokes = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>其中匿名成员 Circle 和 Point 都有自己的名字 —— 就是命名的类型名字 —— 但是这些名字在点操作符中是可选的。我们在访问子成员的时候可以忽略任何匿名成员部分。</p><p>不幸的是，结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = Wheel&#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">20</span>&#125;                       <span class="comment">// compile error: unknown fields</span></span><br><span class="line">w = Wheel&#123;X: <span class="number">8</span>, Y: <span class="number">8</span>, Radius: <span class="number">5</span>, Spokes: <span class="number">20</span>&#125; <span class="comment">// compile error: unknown fields</span></span><br></pre></td></tr></table></figure><p>结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法，它们彼此是等价的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">w = Wheel&#123;Circle&#123;Point&#123;<span class="number">8</span>, <span class="number">8</span>&#125;, <span class="number">5</span>&#125;, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">w = Wheel&#123;</span><br><span class="line">    Circle: Circle&#123;</span><br><span class="line">        Point:  Point&#123;X: <span class="number">8</span>, Y: <span class="number">8</span>&#125;,</span><br><span class="line">        Radius: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    Spokes: <span class="number">20</span>, <span class="comment">// <span class="doctag">NOTE:</span> trailing comma necessary here (and at Radius)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, w)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></span><br><span class="line"></span><br><span class="line">w.X = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, w)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></span><br></pre></td></tr></table></figure><p><em>需要注意的是 <code>Printf</code> 函数中 <code>%v</code> 参数包含的 <code>#</code> 副词，它表示用和 Go 语言类似的语法打印值。对于结构体类型来说，将包含每个成员的名字。</em></p><p><strong>因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。同时，因为成员的名字是由其类型隐式地决定的，所以匿名成员也有可见性的规则约束。</strong> 在上面的例子中，Point 和 Circle 匿名成员都是导出的。即使它们不导出（比如改成小写字母开头的 point 和 circle），我们依然可以用简短形式访问匿名成员嵌套的成员</p><p><strong>但是在包外部，因为 circle 和 point 没有导出，不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。</strong></p><p>其实任何命名的类型都可以作为结构体的匿名成员。但是为什么要嵌入一个没有任何子成员类型的匿名成员类型呢？</p><p>答案是匿名类型的方法集。<strong>简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。实际上，外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。这个机制可以用于将一些有简单行为的对象组合成有复杂行为的对象。</strong></p><blockquote><p>组合是 Go 语言中面向对象编程的核心</p></blockquote><h2 id="4-5-JSON"><a href="#4-5-JSON" class="headerlink" title="4.5. JSON"></a>4.5. JSON</h2><p>Go 语言对于标准格式的编码和解码都有良好的支持，由标准库中的 <code>encoding/json</code>、<code>encoding/xml</code>、<code>encoding/asn1</code> 等包提供支持（译注：Protocol Buffers 的支持由 <code>github.com/golang/protobuf</code> 包提供），并且这类包都有着相似的 API 接口。</p><p>考虑一个应用程序，该程序负责收集各种电影评论并提供反馈功能。它的 Movie 数据类型和一个典型的表示电影的值列表如下所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">Title <span class="keyword">string</span></span><br><span class="line">Year <span class="keyword">int</span> <span class="string">`json:released`</span></span><br><span class="line">Color <span class="keyword">bool</span> <span class="string">`json:"color,omitempty"`</span></span><br><span class="line">Actors []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> movies = []Movie&#123;</span><br><span class="line">&#123;Title: <span class="string">"Casablanca"</span>, Year: <span class="number">1942</span>, Color: <span class="literal">false</span>,</span><br><span class="line">Actors: []<span class="keyword">string</span>&#123;<span class="string">"Humphrey Bogart"</span>, <span class="string">"Ingrid Bergman"</span>&#125;&#125;,</span><br><span class="line">&#123;Title: <span class="string">"Cool Hand Luke"</span>, Year: <span class="number">1967</span>, Color: <span class="literal">true</span>,</span><br><span class="line">Actors: []<span class="keyword">string</span>&#123;<span class="string">"Paul Newman"</span>&#125;&#125;,</span><br><span class="line">&#123;Title: <span class="string">"Bullitt"</span>, Year: <span class="number">1968</span>, Color: <span class="literal">true</span>,</span><br><span class="line">Actors: []<span class="keyword">string</span>&#123;<span class="string">"Steve McQueen"</span>, <span class="string">"Jacqueline Bisset"</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data, err := json.MarshalIndent(movies, <span class="string">""</span>, <span class="string">"    "</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"JSON marshaling failed: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>json.MarshalIndent</code> 函数产生整齐缩进的输出：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Title"</span>: <span class="string">"Casablanca"</span>,</span><br><span class="line">        <span class="attr">"Year"</span>: <span class="number">1942</span>,</span><br><span class="line">        <span class="attr">"Actors"</span>: [</span><br><span class="line">            <span class="string">"Humphrey Bogart"</span>,</span><br><span class="line">            <span class="string">"Ingrid Bergman"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Title"</span>: <span class="string">"Cool Hand Luke"</span>,</span><br><span class="line">        <span class="attr">"Year"</span>: <span class="number">1967</span>,</span><br><span class="line">        <span class="attr">"color"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"Actors"</span>: [</span><br><span class="line">            <span class="string">"Paul Newman"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Title"</span>: <span class="string">"Bullitt"</span>,</span><br><span class="line">        <span class="attr">"Year"</span>: <span class="number">1968</span>,</span><br><span class="line">        <span class="attr">"color"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"Actors"</span>: [</span><br><span class="line">            <span class="string">"Steve McQueen"</span>,</span><br><span class="line">            <span class="string">"Jacqueline Bisset"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p> 在编码时，默认使用 Go 语言结构体的成员名字作为 JSON 的对象（通过 reflect 反射技术），只有导出的结构体成员才会被编码。</p><p> 在上述的例子中，Year 名字的成员在编码后变成了 released，还有 Color 成员编码后变成了小写字母开头的 color。这是因为结构体成员 Tag 所导致的。一个结构体成员 Tag 是和在编译阶段关联到该成员的元信息字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Year  <span class="keyword">int</span>  <span class="string">`json:"released"`</span></span><br><span class="line">Color <span class="keyword">bool</span> <span class="string">`json:"color,omitempty"`</span></span><br></pre></td></tr></table></figure><p><strong>结构体的成员 Tag 可以是任意的字符串面值，但是通常是一系列用空格分隔的 key:”value” 键值对序列；因为值中含有双引号字符，因此成员 Tag 一般用原生字符串面值的形式书写。</strong></p><p>成员 Tag 中 json 对应值的第一部分用于指定 JSON 对象的名字，比如将 Go 语言中的 <code>TotalCount</code> 成员对应到 JSON 中的 <code>total_count</code> 对象。<code>Color</code> 成员的 Tag 还带了一个额外的 <code>omitempty</code> 选项，表示当 Go 语言结构体成员为空或零值时不生成该 JSON 对象</p><p>编码的逆操作是解码，对应将 JSON 数据解码为 Go 语言的数据结构，Go 语言中一般叫 unmarshaling，通过 <code>json.Unmarshal</code> 函数完成。下面的代码将 JSON 格式的电影数据解码为一个结构体 slice，结构体中只有 Title 成员。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> titles []<span class="keyword">struct</span>&#123; Title <span class="keyword">string</span> &#125;</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(data, &amp;titles); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">"JSON unmarshaling failed: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(titles) <span class="comment">// "[&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]"</span></span><br></pre></td></tr></table></figure><h2 id="4-6-文本和-HTML-模板"><a href="#4-6-文本和-HTML-模板" class="headerlink" title="4.6. 文本和 HTML 模板"></a>4.6. 文本和 HTML 模板</h2><p>简单的格式化，使用 Printf 是完全足够的。但是有时候会需要复杂的打印格式，这时候一般需要将格式化代码分离出来以便更安全地修改。这些功能是由 <code>text/template</code> 和 <code>html/template</code> 等模板包提供的，它们提供了一个将变量值填充到一个文本或 HTML 格式的模板的机制。</p><p>一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的 <code>{{action}}</code> 对象。大部分的字符串只是按字面值打印，但是对于 actions 部分将触发其它的行为。<strong>每个 actions 都包含了一个用模板语言书写的表达式，一个 action 虽然简短但是可以输出复杂的打印值，模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流 if-else 语句和 range 循环语句，还有其它实例化模板等诸多特性。</strong></p><p>下面是一个简单的模板字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> templ = <span class="string">`&#123;% raw %&#125;&#123;&#123;.TotalCount&#125;&#125;&#123;% endraw %&#125; issues:</span></span><br><span class="line"><span class="string">&#123;% raw %&#125;&#123;&#123;range .Items&#125;&#125;&#123;% endraw %&#125;----------------------------------------</span></span><br><span class="line"><span class="string">Number: &#123;% raw %&#125;&#123;&#123;.Number&#125;&#125;&#123;% endraw %&#125;</span></span><br><span class="line"><span class="string">User:   &#123;% raw %&#125;&#123;&#123;.User.Login&#125;&#125;&#123;% endraw %&#125;</span></span><br><span class="line"><span class="string">Title:  &#123;% raw %&#125;&#123;&#123;.Title | printf "%.64s"&#125;&#125;&#123;% endraw %&#125;</span></span><br><span class="line"><span class="string">Age:    &#123;% raw %&#125;&#123;&#123;.CreatedAt | daysAgo&#125;&#125;&#123;% endraw %&#125; days</span></span><br><span class="line"><span class="string">&#123;% raw %&#125;&#123;&#123;end&#125;&#125;&#123;% endraw %&#125;`</span></span><br></pre></td></tr></table></figure><p>这个模板先打印匹配到的 issue 总数，然后打印每个 issue 的编号、创建用户、标题还有存在的时间。<strong>对于每一个 action，都有一个当前值的概念，对应点操作符，写作 <code>.</code>。当前值 <code>.</code> 最初被初始化为调用模板时的参数，在当前例子中对应 IssuesSearchResult 类型的变量。</strong> 模板中 <code>{{.TotalCount}}</code> 对应 action 将展开为结构体中 TotalCount 成员以默认的方式打印的值。模板中 <code>{{range .Items}}</code> 和 <code>{{end}}</code> 对应一个循环 action，因此它们之间的内容可能会被展开多次，循环每次迭代的当前值对应当前的 Items 元素的值。</p><p>在一个 action 中，<code>|</code> 操作符表示将前一个表达式的结果作为后一个函数的输入，类似于 UNIX 中管道的概念。</p><p>生成模板的输出需要两个处理步骤。第一步是要分析模板并转为内部表示，然后基于指定的输入执行模板。分析模板部分一般只需要执行一次。下面的代码创建并分析上面定义的模板 <code>templ</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">report, err := template.New(<span class="string">"report"</span>).</span><br><span class="line">    Funcs(template.FuncMap&#123;<span class="string">"daysAgo"</span>: daysAgo&#125;).</span><br><span class="line">    Parse(templ)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意方法调用链的顺序：<code>template.New</code> 先创建并返回一个模板；<code>Funcs</code> 方法将 <code>daysAgo</code> 等自定义函数注册到模板中，并返回模板；最后调用 <code>Parse</code> 函数分析模板。</p><p>因为模板通常在编译时就测试好了，如果模板解析失败将是一个致命的错误。<code>template.Must</code> 辅助函数可以简化这个致命错误的处理：它接受一个模板和一个 error 类型的参数，检测 error 是否为 <code>nil</code>（如果不是 <code>nil</code> 则发出 panic 异常），然后返回传入的模板。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> report = template.Must(template.New(<span class="string">"issuelist"</span>).</span><br><span class="line">    Funcs(template.FuncMap&#123;<span class="string">"daysAgo"</span>: daysAgo&#125;).</span><br><span class="line">    Parse(templ))</span><br></pre></td></tr></table></figure><p>一旦模板创建完成，我们就能根据输入源生成我们想要的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result, err := SearchIssues(os.Args[<span class="number">1</span>:])</span><br><span class="line"><span class="keyword">if</span> err := report.Execute(os.Stdout, result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;4-1-数组&quot;&gt;&lt;a href=&quot;#4-1-数组&quot; class=&quot;headerlink&quot; title=&quot;4.1. 数组&quot;&gt;&lt;/a&gt;4.1. 数组&lt;/h2&gt;&lt;p&gt;数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，
      
    
    </summary>
    
      <category term="Go 语言圣经" scheme="https://homholueng.github.io/categories/Go-%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"/>
    
    
      <category term="Go" scheme="https://homholueng.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言圣经 - 3. 基础数据类型</title>
    <link href="https://homholueng.github.io/2019/07/24/gopl-basic-type/"/>
    <id>https://homholueng.github.io/2019/07/24/gopl-basic-type/</id>
    <published>2019-07-24T12:30:20.000Z</published>
    <updated>2019-07-25T05:03:52.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1-整形"><a href="#3-1-整形" class="headerlink" title="3.1. 整形"></a>3.1. 整形</h2><p>Go 语言同时提供了有符号和无符号类型的整数运算。这里有 <code>int8</code>、<code>int16</code>、<code>int32</code> 和 <code>int64</code> 四种截然不同大小的有符号整数类型，分别对应 8、16、32、64bit 大小的有符号整数，与此对应的是 <code>uint8</code>、<code>uint16</code>、<code>uint32</code> 和 <code>uint64</code> 四种无符号整数类型。</p><p>这里还有两种一般对应特定 CPU 平台机器字大小的有符号和无符号整数 <code>int</code> 和 <code>uint</code>，其大小会根据当前运行环境来确定。</p><p>Unicode 字符 <code>rune</code> 类型是和 <code>int32</code> 等价的类型，通常用于表示一个 Unicode 码点。这两个名称可以互换使用。同样 <code>byte</code> 也是 <code>uint8</code> 类型的等价类型，<code>byte</code> 类型一般用于强调数值是一个原始的数据而不是一个小的整数。</p><p>最后，还有一种无符号的整数类型 <code>uintptr</code>，没有指定具体的 bit 大小但是足以容纳指针。</p><p><strong><code>int</code> 和 <code>int32</code> 也是不同的类型，即使 <code>int</code> 的大小也是 32bit，在需要将 <code>int</code> 当作 <code>int32</code> 类型的地方需要一个显式的类型转换操作。</strong></p><p>任何大小的整数字面值都可以用以 0 开始的八进制格式书写，例如 <code>0666</code>；或用以 0x 或 0X 开头的十六进制格式书写，例如 <code>0xdeadbeef</code>。</p><h3 id="fmt-使用技巧"><a href="#fmt-使用技巧" class="headerlink" title="fmt 使用技巧"></a>fmt 使用技巧</h3><p>我们能够通过格式化标志的副词来告诉 <code>fmt</code> 要用哪一个参数进行格式化的输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="keyword">int64</span>(<span class="number">0xdeadbeef</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%d %[1]x %#[1]x %#[1]X\n"</span>, x) <span class="comment">// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF</span></span><br></pre></td></tr></table></figure><p>同时，打印字符时，使用 <code>%q</code> 能够打印带单引号的字符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ascii := <span class="string">'a'</span></span><br><span class="line">fmt.Printf(<span class="string">"%d %[1]c %[1]q\n"</span>, ascii)   <span class="comment">// "97 a 'a'"</span></span><br></pre></td></tr></table></figure><h2 id="3-2-浮点数"><a href="#3-2-浮点数" class="headerlink" title="3.2. 浮点数"></a>3.2. 浮点数</h2><p>Go 语言提供了两种精度的浮点数，<code>float32</code> 和 <code>float64</code>。</p><p>浮点数的范围极限值可以在 <code>math</code> 包找到。常量 <code>math.MaxFloat32</code> 表示 <code>float32</code> 能表示的最大数值，大约是 <code>3.4e38</code>；对应的 <code>math.MaxFloat64</code> 常量大约是 <code>1.8e308</code>。</p><h2 id="3-3-复数"><a href="#3-3-复数" class="headerlink" title="3.3. 复数"></a>3.3. 复数</h2><p>Go 语言提供了两种精度的复数类型：<code>complex64</code> 和 <code>complex128</code>，分别对应 <code>float32</code> 和 <code>float64</code> 两种浮点数精度。内置的 <code>complex</code> 函数用于构建复数，内建的 <code>real</code> 和 <code>imag</code> 函数分别返回复数的实部和虚部：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">complex128</span> = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1+2i</span></span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">complex128</span> = <span class="built_in">complex</span>(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 3+4i</span></span><br><span class="line">fmt.Println(x*y)                 <span class="comment">// "(-5+10i)"</span></span><br><span class="line">fmt.Println(<span class="built_in">real</span>(x*y))           <span class="comment">// "-5"</span></span><br><span class="line">fmt.Println(<span class="built_in">imag</span>(x*y))           <span class="comment">// "10"</span></span><br></pre></td></tr></table></figure><h2 id="3-4-布尔型"><a href="#3-4-布尔型" class="headerlink" title="3.4. 布尔型"></a>3.4. 布尔型</h2><p>布尔值并不会隐式转换为数字值 <code>0</code> 或 <code>1</code>，反之亦然。</p><h2 id="3-5-字符串"><a href="#3-5-字符串" class="headerlink" title="3.5. 字符串"></a>3.5. 字符串</h2><p>一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括 <code>byte</code> 值 <code>0</code>，但是通常是用来包含人类可读的文本。文本字符串通常被解释为采用 UTF8 编码的 Unicode 码点（<code>rune</code>）序列。</p><p>内置的 <code>len</code> 函数可以返回一个字符串中的字节数目（<strong>不是 <code>rune</code> 字符数目</strong>），索引操作 <code>s[i]</code> 返回第 i 个字节的字节值。</p><p><strong>第 i 个字节并不一定是字符串的第 i 个字符，因为对于非 ASCII 字符的 UTF8 编码会要两个或多个字节。</strong></p><p>因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"hello world"</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">'L'</span> <span class="comment">// compile error: cannot assign to s[0]</span></span><br></pre></td></tr></table></figure><p>不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串 <code>s</code> 和对应的子字符串切片 <code>s[7:]</code> 的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存。 </p><h3 id="3-5-1-字符串面值"><a href="#3-5-1-字符串面值" class="headerlink" title="3.5.1. 字符串面值"></a>3.5.1. 字符串面值</h3><p>一个原生的字符串面值形式是 `…`，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行</p><h4 id="3-5-3-UTF-8"><a href="#3-5-3-UTF-8" class="headerlink" title="3.5.3. UTF-8"></a>3.5.3. UTF-8</h4><p>UTF8 是一个将 Unicode 码点编码为字节序列的变长编码。UTF8 编码使用 1 到 4 个字节来表示每个 Unicode 码点，每个符号编码后第一个字节的高端 bit 位用于表示编码总共有多少个字节。</p><p>Go 语言的源文件采用 UTF8 编码，并且 Go 语言处理 UTF8 编码的文本也很出色。<code>unicode</code> 包提供了诸多处理 <code>rune</code> 字符相关功能的函数（比如区分字母和数字，或者是字母的大写和小写转换等），<code>unicode/utf8</code> 包则提供了用于 <code>rune</code> 字符序列的 UTF8 编码和解码的功能。</p><p>得益于 UTF8 编码优良的设计，诸多字符串操作都不需要解码操作，对于 UTF8 编码后文本的处理和原始的字节处理逻辑是一样的。</p><p>另一方面，如果我们真的关心每个 Unicode 字符，我们可以使用其它处理方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"unicode/utf8"</span></span><br><span class="line"></span><br><span class="line">s := <span class="string">"Hello, 世界"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))                    <span class="comment">// "13"</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(s)) <span class="comment">// "9"</span></span><br></pre></td></tr></table></figure><p>Go 语言的 <code>range</code> 循环在处理字符串的时候，会自动隐式解码 UTF8 字符串，但是其对于非 ASCII，索引更新的步长将超过 1 个字节。</p><h3 id="3-5-4-字符串和-Byte-切片"><a href="#3-5-4-字符串和-Byte-切片" class="headerlink" title="3.5.4. 字符串和 Byte 切片"></a>3.5.4. 字符串和 Byte 切片</h3><p>标准库中有四个包对字符串处理尤为重要：<code>bytes</code>、<code>strings</code>、<code>strconv</code> 和 <code>unicode</code> 包。</p><ul><li><code>strings</code> 包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。</li><li><code>bytes</code> 包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的 <code>[]byte</code> 类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用 <code>bytes.Buffer</code> 类型会更有效。</li><li><code>strconv</code> 包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</li><li><code>unicode</code> 包提供了 <code>IsDigit</code>、<code>IsLetter</code>、<code>IsUpper</code> 和 <code>IsLower</code> 等类似功能，它们用于给字符分类。</li></ul><p><code>bytes</code> 包还提供了 <code>Buffer</code> 类型用于字节 <code>slice</code> 的缓存。一个 <code>Buffer</code> 开始是空的，但是随着 <code>string</code>、<code>byte</code> 或 <code>[]byte</code> 等类型数据的写入可以动态增长。</p><h2 id="3-6-常量"><a href="#3-6-常量" class="headerlink" title="3.6. 常量"></a>3.6. 常量</h2><p>常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：<code>boolean</code>、<code>string</code> 或数字。</p><p>一个常量的声明语句定义了常量的名字，和变量的声明语法类似，常量的值不可修改，这样可以防止在运行期被意外或恶意的修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14159</span> <span class="comment">// approximately; math.Pi is a better approximation</span></span><br></pre></td></tr></table></figure><p>常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：<code>len</code>、<code>cap</code>、<code>real</code>、<code>imag</code>、<code>complex</code> 和 <code>unsafe.Sizeof</code>。</p><h3 id="3-6-1-iota-常量生成器"><a href="#3-6-1-iota-常量生成器" class="headerlink" title="3.6.1. iota 常量生成器"></a>3.6.1. iota 常量生成器</h3><p>常量声明可以使用 <code>iota</code> 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 <code>const</code> 声明语句中，在第一个声明的常量所在的行，<code>iota</code> 将会被置为 0，然后在每一个有常量声明的行加一。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weekday <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="3-6-2-无类型常量"><a href="#3-6-2-无类型常量" class="headerlink" title="3.6.2. 无类型常量"></a>3.6.2. 无类型常量</h3><p>Go 语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如 <code>int</code> 或 <code>float64</code>，或者是类似 <code>time.Duration</code> 这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有 <code>256bit</code> 的运算精度。这里有六种未明确类型的常量类型，分别是</p><ul><li>无类型的布尔型</li><li>无类型的整数</li><li>无类型的字符</li><li>无类型的浮点数</li><li>无类型的复数</li><li>无类型的字符串</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;3-1-整形&quot;&gt;&lt;a href=&quot;#3-1-整形&quot; class=&quot;headerlink&quot; title=&quot;3.1. 整形&quot;&gt;&lt;/a&gt;3.1. 整形&lt;/h2&gt;&lt;p&gt;Go 语言同时提供了有符号和无符号类型的整数运算。这里有 &lt;code&gt;int8&lt;/code&gt;、&lt;code
      
    
    </summary>
    
      <category term="Go 语言圣经" scheme="https://homholueng.github.io/categories/Go-%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"/>
    
    
      <category term="Go" scheme="https://homholueng.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言圣经 - 2. 程序结构</title>
    <link href="https://homholueng.github.io/2019/07/24/gopl-program-structure/"/>
    <id>https://homholueng.github.io/2019/07/24/gopl-program-structure/</id>
    <published>2019-07-24T11:29:06.000Z</published>
    <updated>2019-07-25T05:03:52.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3. 变量"></a>2.3. 变量</h2><p>var 声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 变量名字 类型 = 表达式</span><br></pre></td></tr></table></figure><p>其中 <code>类型</code> 或 <code>= 表达式</code> 两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。 数值类型变量对应的零值是 <code>0</code>，布尔类型变量对应的零值是 <code>false</code>，字符串类型对应的零值是空字符串，接口或引用类型（包括 slice、指针、map、chan 和函数）变量对应的零值是 <code>nil</code>。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。</p><h3 id="2-3-1-简短变量声明"><a href="#2-3-1-简短变量声明" class="headerlink" title="2.3.1. 简短变量声明"></a>2.3.1. 简短变量声明</h3><p>在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以 <code>名字 := 表达式</code> 形式声明变量，变量的类型根据表达式来自动推导：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">j := <span class="number">1.0</span></span><br><span class="line">s := <span class="string">""</span></span><br></pre></td></tr></table></figure><p>这里有一个比较微妙的地方：简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。</p><p>简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">f, err := os.Create(outfile) <span class="comment">// compile error: no new variables</span></span><br></pre></td></tr></table></figure><p><strong>简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。</strong></p><h3 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2. 指针"></a>2.3.2. 指针</h3><p>如果用 <code>var x int</code> 声明语句声明一个 <code>x</code> 变量，那么 <code>&amp;x</code> 表达式（取 <code>x</code> 变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是 <code>*int</code>，指针被称之为 “指向 <code>int</code> 类型的指针”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">p := &amp;x         <span class="comment">// p, of type *int, points to x</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// "1"</span></span><br><span class="line">*p = <span class="number">2</span>          <span class="comment">// equivalent to x = 2</span></span><br><span class="line">fmt.Println(x)  <span class="comment">// "2"</span></span><br></pre></td></tr></table></figure><p>任何类型的指针的零值都是 <code>nil</code>。如果 <code>p</code> 指向某个有效变量，那么 <code>p != nil</code> 测试为真。</p><h3 id="2-3-3-new-函数"><a href="#2-3-3-new-函数" class="headerlink" title="2.3.3. new 函数"></a>2.3.3. new 函数</h3><p>另一个创建变量的方法是调用内建的 <code>new</code> 函数。表达式 <code>new (T)</code> 将创建一个 <code>T</code> 类型的匿名变量，初始化为 <code>T</code> 类型的零值，然后返回变量地址，返回的指针类型为 <code>*T</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="keyword">int</span>)   <span class="comment">// p, *int 类型, 指向匿名的 int 变量</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// "0"</span></span><br><span class="line">*p = <span class="number">2</span>          <span class="comment">// 设置 int 匿名变量的值为 2</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// "2"</span></span><br></pre></td></tr></table></figure><p>由于 <code>new</code> 只是一个预定义的函数，它并不是一个关键字，因此我们可以将 <code>new</code> 名字重新定义为别的类型。例如下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delta</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">new</span> - old &#125;</span><br></pre></td></tr></table></figure><p>由于 <code>new</code> 被定义为 int 类型的变量名，因此在 <code>delta</code> 函数内部是无法使用内置的 <code>new</code> 函数的。</p><h3 id="2-3-4-变量的生命周期"><a href="#2-3-4-变量的生命周期" class="headerlink" title="2.3.4. 变量的生命周期"></a>2.3.4. 变量的生命周期</h3><p>变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。</p><p>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用 <code>var</code> 还是 <code>new</code> 声明变量的方式决定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    global = &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">    y := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">    *y = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>f</code> 函数里的 <code>x</code> 变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的 <code>global</code> 变量找到，虽然它是在函数内部定义的；用 Go 语言的术语说，这个 <code>x</code> 局部变量从函数 <code>f</code> 中逃逸了。相反，当 g 函数返回时，变量 <code>*y</code> 将是不可达的，也就是说可以马上被回收的。因此，<code>*y</code> 并没有从函数 <code>g</code> 中逃逸，编译器可以选择在栈上分配 <code>*y</code> 的存储空间（译注：也可以选择在堆上分配，然后由 Go 语言的 GC 回收这个变量的内存空间），虽然这里用的是 <code>new</code> 方式。</p><h2 id="2-4-赋值"><a href="#2-4-赋值" class="headerlink" title="2.4. 赋值"></a>2.4. 赋值</h2><h3 id="2-4-2-可赋值性"><a href="#2-4-2-可赋值性" class="headerlink" title="2.4.2. 可赋值性"></a>2.4.2. 可赋值性</h3><p>赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为。</p><p>不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。</p><p>可赋值性的规则对于不同类型有着不同要求，对每个新类型特殊的地方我们会专门解释。对于目前我们已经讨论过的类型，它的规则是简单的：类型必须完全匹配，<code>nil</code> 可以赋值给任何指针或引用类型的变量。常量则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。</p><p>对于两个值是否可以用 <code>==</code> 或 <code>!=</code> 进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。</p><h2 id="2-5-类型"><a href="#2-5-类型" class="headerlink" title="2.5. 类型"></a>2.5. 类型</h2><p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名字 底层类型</span><br></pre></td></tr></table></figure><p>例如下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package tempconv performs Celsius and Fahrenheit temperature computations.</span></span><br><span class="line"><span class="keyword">package</span> tempconv</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Celsius <span class="keyword">float64</span>    <span class="comment">// 摄氏温度</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="keyword">float64</span> <span class="comment">// 华氏温度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    AbsoluteZeroC Celsius = <span class="number">-273.15</span> <span class="comment">// 绝对零度</span></span><br><span class="line">    FreezingC     Celsius = <span class="number">0</span>       <span class="comment">// 结冰点温度</span></span><br><span class="line">    BoilingC      Celsius = <span class="number">100</span>     <span class="comment">// 沸水温度</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CToF</span><span class="params">(c Celsius)</span> <span class="title">Fahrenheit</span></span> &#123; <span class="keyword">return</span> Fahrenheit(c*<span class="number">9</span>/<span class="number">5</span> + <span class="number">32</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FToC</span><span class="params">(f Fahrenheit)</span> <span class="title">Celsius</span></span> &#123; <span class="keyword">return</span> Celsius((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>) &#125;</span><br></pre></td></tr></table></figure><p>我们在这个包声明了两种类型：<code>Celsius</code> 和 <code>Fahrenheit</code> 分别对应不同的温度单位。它们虽然有着相同的底层类型 <code>float64</code>，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。</p><p><strong>刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误</strong>，因此需要一个类似 <code>Celsius(t)</code> 或 <code>Fahrenheit(t)</code> 形式的显式转型操作才能将 <code>float64</code> 转为对应的类型。</p><p>比较运算符 <code>==</code> 和 <code>&lt;</code> 也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c Celsius</span><br><span class="line"><span class="keyword">var</span> f Fahrenheit</span><br><span class="line">fmt.Println(c == <span class="number">0</span>)          <span class="comment">// "true"</span></span><br><span class="line">fmt.Println(f &gt;= <span class="number">0</span>)          <span class="comment">// "true"</span></span><br><span class="line">fmt.Println(c == f)          <span class="comment">// compile error: type mismatch</span></span><br><span class="line">fmt.Println(c == Celsius(f)) <span class="comment">// "true"!</span></span><br></pre></td></tr></table></figure><h2 id="2-6-包和文件"><a href="#2-6-包和文件" class="headerlink" title="2.6. 包和文件"></a>2.6. 包和文件</h2><p>通常一个包所在目录路径的后缀是包的导入路径；例如包 <code>gopl.io/ch1/helloworld</code> 对应的目录路径是 <code>$GOPATH/src/gopl.io/ch1/helloworld</code>。</p><p>每个源文件的开头都是以包的声明语句开始，用来指明包的名字。</p><h3 id="2-6-2-包的初始化"><a href="#2-6-2-包的初始化" class="headerlink" title="2.6.2. 包的初始化"></a>2.6.2. 包的初始化</h3><p>包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b + c <span class="comment">// a 第三个初始化, 为 3</span></span><br><span class="line"><span class="keyword">var</span> b = f()   <span class="comment">// b 第二个初始化, 为 2, 通过调用 f (依赖c)</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>     <span class="comment">// c 第一个初始化, 为 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> c + <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>如果包中含有多个 .go 源文件，它们将按照发给编译器的顺序进行初始化，<strong>Go 语言的构建工具首先会将 .go 文件根据文件名排序，然后依次调用编译器编译。</strong></p><p>对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的 <code>init</code> 初始化函数来简化初始化工作。每个文件都可以包含多个 <code>init</code> 初始化函数</p><p>这样的 <code>init</code> 初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的 <code>init</code> 初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。</p><h2 id="2-7-作用域"><a href="#2-7-作用域" class="headerlink" title="2.7. 作用域"></a>2.7. 作用域</h2><p><strong>声明语句的作用域是指源代码中可以有效使用这个名字的范围。</strong></p><p>不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。</p><p>句法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。句法块内部声明的名字是无法被外部块访问的。这个块决定了内部声明的名字的作用域范围。</p><p>我们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为词法块。对全局的源代码来说，存在一个整体的词法块，称为全局词法块；对于每个包；每个 for、if 和 switch 语句，也都有对应词法块；每个 switch 或 select 的分支也有独立的词法块；当然也包括显式书写的词法块（花括弧包含的语句）。</p><p>在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2-3-变量&quot;&gt;&lt;a href=&quot;#2-3-变量&quot; class=&quot;headerlink&quot; title=&quot;2.3. 变量&quot;&gt;&lt;/a&gt;2.3. 变量&lt;/h2&gt;&lt;p&gt;var 声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般
      
    
    </summary>
    
      <category term="Go 语言圣经" scheme="https://homholueng.github.io/categories/Go-%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"/>
    
    
      <category term="Go" scheme="https://homholueng.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言圣经 - 1. 入门</title>
    <link href="https://homholueng.github.io/2019/07/18/gopl-getting-started/"/>
    <id>https://homholueng.github.io/2019/07/18/gopl-getting-started/</id>
    <published>2019-07-18T13:59:05.000Z</published>
    <updated>2019-07-28T14:26:50.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-2-命令行参数"><a href="#1-2-命令行参数" class="headerlink" title="1.2. 命令行参数"></a>1.2. 命令行参数</h2><p>通过 <code>os.Args</code> 切片能够拿到程序启动时得到的命令行参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> </span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s, sep <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">s += sep + arg</span><br><span class="line">sep = <span class="string">" "</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以下命令会输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> go run echo1.go 1 2 3 4 5</span><br><span class="line">/var/folders/8v/11x3hg3x5g758rwj8kl4c42w0000gn/T/go-build732224661/b001/exe/echo1 1 2 3 4 5</span><br></pre></td></tr></table></figure><h2 id="1-3-查找重复的行"><a href="#1-3-查找重复的行" class="headerlink" title="1.3. 查找重复的行"></a>1.3. 查找重复的行</h2><p>类似于 C 或其它语言里的 <code>printf</code> 函数，<code>fmt.Printf</code> 函数对一些表达式产生格式化输出。该函数的首个参数是个格式字符串，指定后续参数被如何格式化，<code>Printf</code> 有一大堆这种转换，Go 程序员称之为动词（verb）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%d          十进制整数</span><br><span class="line">%x, %o, %b  十六进制，八进制，二进制整数。</span><br><span class="line">%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00</span><br><span class="line">%t          布尔：true或false</span><br><span class="line">%c          字符（rune） (Unicode码点)</span><br><span class="line">%s          字符串</span><br><span class="line">%q          带双引号的字符串&quot;abc&quot;或带单引号的字符&apos;c&apos;</span><br><span class="line">%v          变量的自然形式（natural format）</span><br><span class="line">%T          变量的类型</span><br><span class="line">%%          字面上的百分号标志（无操作数）</span><br></pre></td></tr></table></figure><h2 id="1-8-本章要点"><a href="#1-8-本章要点" class="headerlink" title="1.8. 本章要点"></a>1.8. 本章要点</h2><p>在你开始写一个新程序之前，最好先去检查一下是不是已经有了现成的库可以帮助你更高效地完成这件事情。你可以在 <a href="https://golang.org/pkg" target="_blank" rel="noopener">https://golang.org/pkg</a> 和 <a href="https://godoc.org" target="_blank" rel="noopener">https://godoc.org</a> 中找到标准库和社区写的 package。godoc 这个工具可以让你直接在本地命令行阅读标准库的文档。比如下面这个例子。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> go doc http.ListenAndServe</span><br><span class="line">package http // import "net/http"</span><br><span class="line">func ListenAndServe(addr string, handler Handler) error</span><br><span class="line">    ListenAndServe listens on the TCP network address addr and then</span><br><span class="line">    calls Serve with handler to handle requests on incoming connections.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-2-命令行参数&quot;&gt;&lt;a href=&quot;#1-2-命令行参数&quot; class=&quot;headerlink&quot; title=&quot;1.2. 命令行参数&quot;&gt;&lt;/a&gt;1.2. 命令行参数&lt;/h2&gt;&lt;p&gt;通过 &lt;code&gt;os.Args&lt;/code&gt; 切片能够拿到程序启动时得到的命令
      
    
    </summary>
    
      <category term="Go 语言圣经" scheme="https://homholueng.github.io/categories/Go-%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"/>
    
    
      <category term="Go" scheme="https://homholueng.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 12 - 继承的优缺点</title>
    <link href="https://homholueng.github.io/2019/07/13/fluent-python-ad-and-disad-of-inherit/"/>
    <id>https://homholueng.github.io/2019/07/13/fluent-python-ad-and-disad-of-inherit/</id>
    <published>2019-07-13T10:05:21.000Z</published>
    <updated>2019-07-25T05:03:52.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="12-1-子类化内置类型很麻烦"><a href="#12-1-子类化内置类型很麻烦" class="headerlink" title="12.1 子类化内置类型很麻烦"></a>12.1 子类化内置类型很麻烦</h2><p><strong>使用 C 语言实现的内置类型不会调用用户顶以的类覆盖的特殊方法，如 <code>dict</code> 的子类覆盖的 <code>__getitem__()</code> 方法不会被内置类型的 <code>get()</code> 方法调用。</strong></p><p>具体我们可以看看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">DoppelDict</span><span class="params">(dict)</span>:</span> </span><br><span class="line">   ...:     <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span> </span><br><span class="line">   ...:         super().__setitem__(key, [value] * <span class="number">2</span>) </span><br><span class="line">   ...:                                                                                   </span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: dd = DoppelDict(one=<span class="number">1</span>)                                                            </span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: dd                                                                                </span><br><span class="line">Out[<span class="number">3</span>]: &#123;<span class="string">'one'</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: dd[<span class="string">'two'</span>] = <span class="number">2</span>                                                                     </span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: dd                                                                                </span><br><span class="line">Out[<span class="number">5</span>]: &#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: [<span class="number">2</span>, <span class="number">2</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: dd.update(three=<span class="number">3</span>)                                                                </span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: dd                                                                                </span><br><span class="line">Out[<span class="number">7</span>]: &#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: [<span class="number">2</span>, <span class="number">2</span>], <span class="string">'three'</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>所以，直接实例化内置类型（如 <code>dict</code>，<code>list</code> 或 <code>str</code>）容易出错，用户自己定义的类，应该继承 <code>collections</code> 模块中的类，如 <code>UserDict</code>，<code>UserList</code> 和 <code>UserString</code>，这样就不会出现内置类型不调用子类覆盖的特殊方法的尴尬场面。</p><h2 id="12-2-多重继承和方法的解析顺序"><a href="#12-2-多重继承和方法的解析顺序" class="headerlink" title="12.2 多重继承和方法的解析顺序"></a>12.2 多重继承和方法的解析顺序</h2><p>Python 会按照特定的顺序遍历继承图来决定如何解析子类调用的方法，这个顺序叫做方法解析顺序（Method Resolution Order）。每个类都有一个名为 <code>__mro__</code> 的属性，它的值是一个元组，按照方法解析顺序列出该类的各个超类，同时，MRO 还与类声明超类的顺序有关。</p><h2 id="12-4-处理多重继承"><a href="#12-4-处理多重继承" class="headerlink" title="12.4 处理多重继承"></a>12.4 处理多重继承</h2><ol><li>把接口继承和实现继承区分开：继承接口是为了实现“是什么”的关系，继承实现是为了重用代码</li><li>使用抽象基类表示接口</li><li>通过混入重用代码：如果一个类的作用是为多个不相关的子类提供方法实现，从而实现重用，但不体现“是什么”关系，应该把那个类明确地定义为混入类（mixin class）。从概念上讲，混入不定义新类型，只是打包方法，便于重用。</li><li>在名称中明确指明混入：混用类的类名强烈建议使用 Mixin 作为后缀。</li><li>抽象基类可以作为混入，反过来则不成立</li><li>不要子类化多个具体类：具体类的超类中除了一个具体超类之外，其余的应该都是抽象基类或混入</li><li>为用户提供聚合类：如果抽象基类或混入的组合对客户代码非常有用，那就提供一个类，使用易于理解的方式把它们结合起来。</li><li>优先使用对象组合而不是类继承</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;12-1-子类化内置类型很麻烦&quot;&gt;&lt;a href=&quot;#12-1-子类化内置类型很麻烦&quot; class=&quot;headerlink&quot; title=&quot;12.1 子类化内置类型很麻烦&quot;&gt;&lt;/a&gt;12.1 子类化内置类型很麻烦&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;使用 C 语言实现的
      
    
    </summary>
    
      <category term="Fluent Python" scheme="https://homholueng.github.io/categories/Fluent-Python/"/>
    
    
      <category term="Python" scheme="https://homholueng.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
